<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Golf Course Map with Oriented Hole Selector (Optimized)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link
    href="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Widgets/widgets.css"
    rel="stylesheet"
  />
  <script src="https://cesium.com/downloads/cesiumjs/releases/1.120/Build/Cesium/Cesium.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/osmtogeojson@2.2.12/osmtogeojson.js"></script>
  
  <!-- Performance-optimized modules -->
  <script src="./dependencies/js/performanceManager.js"></script>
  <script src="./dependencies/js/courseDataManager.js"></script>
  
  <!-- Advanced short game modifiers data -->
  <script>
    // Load short game modifiers data
    let shortGameModifiers = {};
    
    async function loadShortGameModifiers() {
      try {
        const response = await fetch('./dependencies/short_game_modifiers.json');
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        shortGameModifiers = await response.json();
        console.log('Short game modifiers loaded:', Object.keys(shortGameModifiers).length, 'combinations');
      } catch (error) {
        console.error('Failed to load short game modifiers:', error);
        shortGameModifiers = {}; // Fallback to empty object
      }
    }
    
    // Load data when page loads
    loadShortGameModifiers();
    
    // Performance optimization: Cache for terrain sampling results
    const terrainSampleCache = new Map();
    const CACHE_PRECISION = 5; // Decimal places for coordinate rounding
    
    // Cached terrain sampling function
    function sampleTerrainCached(globe, lon, lat) {
      const key = `${lon.toFixed(CACHE_PRECISION)},${lat.toFixed(CACHE_PRECISION)}`;
      
      if (terrainSampleCache.has(key)) {
        return terrainSampleCache.get(key);
      }
      
      try {
        // Use Cesium's globe.getHeight for synchronous terrain sampling
        const cartographic = Cesium.Cartographic.fromDegrees(lon, lat);
        const height = globe.getHeight(cartographic) || 0;
          
        terrainSampleCache.set(key, height);
        
        // Limit cache size to prevent memory issues
        if (terrainSampleCache.size > 1000) {
          const firstKey = terrainSampleCache.keys().next().value;
          terrainSampleCache.delete(firstKey);
        }
        
        return height;
      } catch (error) {
        console.warn('Terrain sampling error:', error);
        return 0;
      }
    }
    
    // Lookup function for short game modifiers and colors
    function getShortGameModifierAndColor(ballLie, greenSlope, elevationChange, greenPercent) {
      // Handle inconsistent JSON key format - some keys have leading spaces
      const keyPrefix = (ballLie.category === 'sidehill' || ballLie.category === 'uphill' || ballLie.category === 'downhill') ? ' ' : '';
      const key = `${keyPrefix}${ballLie.category}_${greenSlope.category}_ ${elevationChange.category}_${greenPercent.category}`;
      const entry = shortGameModifiers[key];
      
      // Debug: Print key lookup results for first few calls
      window.debugKeyLookupCount = (window.debugKeyLookupCount || 0) + 1;
      if (window.debugKeyLookupCount <= 5) {
        console.log(`Key Lookup Debug ${window.debugKeyLookupCount}:`);
        console.log(`  Generated Key: "${key}"`);
        console.log(`  Found Entry: ${entry ? 'YES' : 'NO'}`);
        if (entry) {
          console.log(`  Modifier: ${entry.modifier}, Color: rgb(${entry.color.r},${entry.color.g},${entry.color.b})`);
        } else {
          console.log(`  Available keys sample:`, Object.keys(shortGameModifiers).slice(0, 3));
        }
      }
      
      if (entry) {
        return {
          modifier: entry.modifier,
          color: Cesium.Color.fromBytes(entry.color.r, entry.color.g, entry.color.b, 160), // 160/255 = ~0.6 alpha
          key: key // Return the key for debugging
        };
      } else {
        return {
          modifier: 0,
          color: Cesium.Color.GRAY.withAlpha(0.6), // Default neutral color
          key: key // Return the key even if not found
        };
      }
    }
  </script>
  
  <style>
    html,
    body,
    #cesiumContainer {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    
    /* Performance indicator */
    #loadingIndicator {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 20px;
      border-radius: 8px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      z-index: 1000;
      display: none;
    }
    
    .progress-bar {
      width: 300px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #357abd);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    #sidebar {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      color: #333;
      padding: 16px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      font-size: 12px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      z-index: 10;
      max-height: 90vh;
      overflow-y: auto;
      min-width: 300px;
    }
    .sidebar-section {
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    }
    .sidebar-section:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }
    .sidebar-section h4 {
      margin: 0 0 8px 0;
      font-size: 13px;
      font-weight: 600;
      color: #2c3e50;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .checkbox-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px 8px;
    }
    .checkbox-grid label {
      margin-bottom: 4px;
      font-size: 11px;
    }
    .compact-input {
      font-size: 11px;
      margin-top: 8px;
    }
    .compact-input input {
      width: 50px !important;
      padding: 3px 6px !important;
      margin-left: 6px !important;
    }
    #sidebar::-webkit-scrollbar {
      width: 6px;
    }
    #sidebar::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }
    #sidebar::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 3px;
    }
    #sidebar label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #555;
    }
    #sidebar select { 
      width: 100%; 
      margin-top: 4px; 
      padding: 8px 12px; 
      border-radius: 8px; 
      border: 1px solid #ddd;
      background: white;
      font-size: 13px;
      transition: border-color 0.2s ease;
    }
    .nav-button.toggle-features {
      background: linear-gradient(135deg, #9b59b6, #8e44ad);
      color: white;
    }
    .nav-button.toggle-features:hover {
      background: linear-gradient(135deg, #8e44ad, #7d3c98);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(155, 89, 182, 0.4);
    }
    .nav-button.toggle-features.active {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
    }
    .nav-button.toggle-features.active:hover {
      background: linear-gradient(135deg, #c0392b, #a93226);
    }
    #sidebar select:focus {
      outline: none;
      border-color: #4a90e2;
      box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
    }
    .distance-display {
      background: linear-gradient(135deg, #34495e, #2c3e50);
      border-radius: 8px;
      padding: 8px;
      text-align: center;
      color: white;
      min-height: 40px;
      display: flex;
      flex-direction: column;
      justify-content: center;
    }
    .display-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      opacity: 0.8;
      margin-bottom: 2px;
    }
    .distance-value {
      font-size: 14px;
      font-weight: 700;
      color: #3498db;
    }
    #sidebar input[type="checkbox"] {
      margin-right: 8px;
      transform: scale(1.1);
    }
    #sidebar input[type="number"] {
      width: 60px;
      padding: 4px 8px;
      border: 1px solid #ddd;
      border-radius: 6px;
      margin-left: 8px;
    }
    #holeSelector {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 3px;
      margin-bottom: 4px;
    }
    #holeSelector button {
      padding: 2px 1px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #4a90e2, #357abd);
      color: white;
      border: none;
      border-radius: 4px;
      transition: all 0.2s ease;
      box-shadow: 0 1px 4px rgba(74, 144, 226, 0.3);
    }
    
    /* Green buttons for tee, fairway, green */
    #holeSelector .green-btn {
      background: linear-gradient(135deg, #27ae60, #229954) !important;
    }
    #holeSelector .green-btn:hover {
      background: linear-gradient(135deg, #229954, #1e8449) !important;
    }
    #holeSelector button:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(74, 144, 226, 0.4);
      background: linear-gradient(135deg, #357abd, #2d6aa0);
    }
    #holeSelector button:active {
      transform: translateY(0);
      box-shadow: 0 1px 4px rgba(74, 144, 226, 0.3);
    }
    
    .nav-separator {
      height: 1px;
      background: linear-gradient(to right, transparent, rgba(0,0,0,0.2), transparent);
      margin: 4px 0;
      grid-column: 1 / -1;
    }
    
    /* Navigation button styles */
    .nav-button {
      display: block;
      width: 100%;
      margin: 3px 0;
      padding: 8px 0;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: 600;
      font-size: 11px;
      transition: all 0.2s ease;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    
    /* Color coding for different button types */
    .nav-button.reset {
      background: linear-gradient(135deg, #27ae60, #229954);
      color: white;
    }
    .nav-button.reset:hover {
      background: linear-gradient(135deg, #229954, #1e8449);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(39, 174, 96, 0.4);
    }
    
    .nav-button.fairway {
      background: linear-gradient(135deg, #27ae60, #229954);
      color: white;
    }
    .nav-button.fairway:hover {
      background: linear-gradient(135deg, #229954, #1e8449);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(39, 174, 96, 0.4);
    }
    
    .nav-button.green {
      background: linear-gradient(135deg, #27ae60, #229954);
      color: white;
    }
    .nav-button.green:hover {
      background: linear-gradient(135deg, #229954, #1e8449);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(39, 174, 96, 0.4);
    }
    
    .nav-button.navy {
      background: linear-gradient(135deg, #09141f, #1a252f);
      color: white;
    }
    .nav-button.navy:hover {
      background: linear-gradient(135deg, #1a252f, #0f1419);
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(44, 62, 80, 0.4);
    }
    #toolbar {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      z-index: 5;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(10px);
      color: #333; 
      padding: 12px; 
      border-radius: 10px; 
      min-width: 240px; 
      max-width: 280px;
      line-height: 1.3em;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    #toolbar h3{
      margin: 0 0 12px;
      font-size: 16px;
      font-weight: 700;
      text-align: center;
      color: #2c3e50;
      border-bottom: 2px solid #4a90e2;
      padding-bottom: 6px;
    }
    .toolbar-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      margin-bottom: 8px;
    }
    .toolbar-row.full {
      grid-template-columns: 1fr;
    }
    #toolbar label{
      display: block;
      margin-bottom: 8px;
      font-size: 11px;
      font-weight: 500;
      color: #555;
    }
    #toolbar input[type="number"],#toolbar input[type="text"]{
      width: 55px;
      box-sizing: border-box;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 3px 5px;
      margin-top: 2px;
      font-size: 9px;
      transition: border-color 0.2s ease;
    }
    #toolbar input[type="number"]:focus,#toolbar input[type="text"]:focus{
      outline: none;
      border-color: #4a90e2;
      box-shadow: 0 0 0 2px rgba(74, 144, 226, 0.1);
    }
    .toolBtn{
      display: block;
      width: 100%;
      margin: 3px 0;
      padding: 6px 0;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #fff;
      font-weight: 600;
      font-size: 9px;
      transition: all 0.2s ease;
      box-shadow: 0 1px 4px rgba(0, 0, 0, 0.2);
    }
    .toolBtn:hover{
      transform: translateY(-1px);
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
    }
    
    /* Color coding for dispersion tool buttons */
    .toolBtn {
      background: linear-gradient(135deg, #9b59b6, #8e44ad);
    }
    .toolBtn:hover {
      background: linear-gradient(135deg, #8e44ad, #7d3c98);
    }
    .toolBtn.active {
      background: linear-gradient(135deg, #4a4a4a, #3a3a3a) !important;
    }
    .toolBtn.active:hover {
      background: linear-gradient(135deg, #3a3a3a, #2a2a2a) !important;
    }
    
    /* Clear All button styling */
    #clearBtn {
      background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
    }
    #clearBtn:hover {
      background: linear-gradient(135deg, #c0392b, #a93226) !important;
    }
    
    #camBtn {
      background: linear-gradient(135deg, #27ae60, #229954);
    }
    #camBtn:hover {
      background: linear-gradient(135deg, #229954, #1e8449);
    }
    
    #shotPovBtn {
      background: linear-gradient(135deg, #3498db, #2980b9);
    }
    #shotPovBtn:hover {
      background: linear-gradient(135deg, #2980b9, #21618c);
    }
    
    .toolbar-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 6px;
      margin: 8px 0;
    }
    .toolbar-grid .toolBtn {
      margin: 0;
    }
    
    /* Course selection collapsible styles */
    #courseSelectionContent {
      transition: all 0.3s ease;
      overflow: hidden;
    }
    #courseSelectionContent.collapsed {
      max-height: 0;
      opacity: 0;
      margin: 0;
      padding: 0;
    }
    #toggleCourseSelection {
      transition: transform 0.3s ease;
    }
    #toggleCourseSelection.collapsed {
      transform: rotate(-90deg);
    }
    
    /* Hole navigation collapsible styles */
    #holeNavigationContent {
      transition: all 0.3s ease;
      overflow: hidden;
    }
    #holeNavigationContent.collapsed {
      max-height: 0;
      opacity: 0;
      margin: 0;
      padding: 0;
    }
    #toggleHoleNavigation {
      transition: transform 0.3s ease;
    }
    #toggleHoleNavigation.collapsed {
      transform: rotate(-90deg);
    }
    
    /* Primary navigation button styles */
    .primary-nav-btn {
      padding: 4px 2px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #4a90e2, #357abd);
      color: white;
      border: none;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .primary-nav-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(74, 144, 226, 0.4);
      background: linear-gradient(135deg, #357abd, #2d6aa0);
    }
    .primary-nav-btn:active {
      transform: translateY(0);
      box-shadow: 0 1px 4px rgba(74, 144, 226, 0.3);
    }
    
    /* View navigation button styles */
    .view-nav-btn {
      padding: 4px 2px;
      font-size: 11px;
      font-weight: 600;
      cursor: pointer;
      background: linear-gradient(135deg, #27ae60, #229954);
      color: white;
      border: none;
      border-radius: 4px;
      transition: all 0.2s ease;
    }
    .view-nav-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.4);
      background: linear-gradient(135deg, #229954, #1e8449);
    }
    .view-nav-btn:active {
      transform: translateY(0);
      box-shadow: 0 1px 4px rgba(39, 174, 96, 0.3);
    }

    /* Sample loading indicator */
    #sampleLoadingIndicator {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 999;
      display: none;
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }

  </style>
</head>
<body>
  <div id="cesiumContainer"></div>
  
  <!-- Loading indicator -->
  <div id="loadingIndicator">
    <div>Loading course data...</div>
    <div class="progress-bar">
      <div class="progress-fill" id="progressFill"></div>
    </div>
    <div id="loadingMessage">Initializing...</div>
  </div>
  
  <!-- Sample loading indicator -->
  <div id="sampleLoadingIndicator">
    Loading samples...
  </div>
  
  <div id="sidebar">
    <div class="sidebar-section" id="courseSelectionSection">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h4 style="margin: 0;">Course Selection</h4>
        <button id="toggleCourseSelection" style="background: none; border: none; font-size: 14px; cursor: pointer; color: #4a90e2; padding: 2px;">▼</button>
      </div>
      
      <div id="courseSelectionContent">
        <!-- Course Search -->
        <div style="margin-bottom: 8px;">
          <input type="text" id="courseSearch" placeholder="Search course name..." 
                 style="width: 100%; padding: 6px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; margin-bottom: 4px;">
          <button id="searchBtn" style="width: 100%; padding: 4px; font-size: 11px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer;">
            Search Courses
          </button>
        </div>
        
        <!-- Course Dropdown -->
        <label>
          <select id="courseSelect">
            <option value="">-- Select Course --</option>
            <option value="30678974,2430678974">Camargo Club (Cincinnati, OH)</option>
            <option value="100953096,2500953096">Coldstream CC (Cincinnati, OH)</option>
            <option value="30431659,2430431659">Maketewah CC (Cincinnati, OH)</option>
            <option value="3606174192">Oakmont CC (Pittsburgh, PA)</option>
            <option value="38066028,2438066028">OSU Golf Club - Scarlet (Columbus, OH)</option>
            <option value="34772911,2434772911">Peachtree GC (Atlanta, GA)</option>
            <option value="12345,12345">Placeholder</option>
            <option value="3604129753">Springfield CC[issues with offset] (Springfield, OH)</option>
            <option value="909175484,3309175484">Totteridge GC (Pittsburgh, PA)</option>
            <option value="112673308,2512673308">TPC Blue Monster (Miami, FL)</option>
            <option value="45009763,2445009763">TPC River's Bend (Cincinnati, OH)</option>
            <option value="78388948,2478388948">TPC Scottsdale - Stadium (Scottsdale, AZ)</option>
            <option value="129019595,2529019595">Windy Knoll GC (Dayton, OH)</option>
          </select>
        </label>
        
        <!-- Search Results -->
        <div id="searchResults" style="display: none; max-height: 200px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; margin-top: 4px;">
        </div>
      </div>
    </div>

    <div class="sidebar-section">
      <h4>Course Features</h4>
      <button id="toggleFeatures" class="nav-button toggle-features">Show Course Features</button>
      <button id="toggleGoogleTiles" class="nav-button" style="background: linear-gradient(135deg, #4285f4, #3367d6); margin-top: 4px;">Show Realistic 3D Tiles</button>
    </div>

    <div class="sidebar-section" id="holeNavigationSection">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h4 style="margin: 0;">Hole Navigation</h4>
        <button id="toggleHoleNavigation" style="background: none; border: none; font-size: 14px; cursor: pointer; color: #4a90e2; padding: 2px;">▼</button>
      </div>
      
      <!-- Primary navigation buttons (always visible) -->
      <div id="primaryNavigation" style="display: grid; grid-template-columns: 1fr 1fr; gap: 3px; margin-bottom: 8px;">
        <button id="prevHoleBtn" class="primary-nav-btn">< Previous</button>
        <button id="nextHoleBtn" class="primary-nav-btn">Next ></button>
      </div>
      <div style="margin-bottom: 8px;">
        <button id="fullCourseBtn" class="primary-nav-btn" style="width: 100%;">Full Course</button>
      </div>
      
      <!-- View buttons (always visible) -->
      <div id="viewButtons" style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 3px; margin-bottom: 8px;">
        <button id="teeViewBtn" class="view-nav-btn">Tee</button>
        <button id="fairwayViewBtn" class="view-nav-btn">Fairway</button>
        <button id="greenViewBtn" class="view-nav-btn">Green</button>
      </div>
      
      <!-- Collapsible detailed navigation (hole numbers only) -->
      <div id="holeNavigationContent">
        <div id="holeSelector"></div>
      </div>
    </div>
    
    <!-- Optimization Toolbar -->
    <div class="sidebar-section" id="optimizationSection" style="margin-top: 16px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
        <h4 style="margin: 0;">Optimization</h4>
        <button id="toggleOptToolbar" style="background: none; border: none; font-size: 14px; cursor: pointer; color: #4a90e2; padding: 2px;">▼</button>
      </div>
      
      <div id="optimizationToolbarContent">
        <!-- Mark Course Conditions -->
        <div style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
          <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: #495057;">Mark Course Conditions</div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-bottom: 6px;">
            <button id="markWaterBtn" class="conditionBtn" style="background: linear-gradient(135deg, #17a2b8, #138496); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              💧 Water
            </button>
            <button id="markBunkerBtn" class="conditionBtn" style="background: linear-gradient(135deg, #ffc107, #e0a800); color: #212529; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🏖️ Bunker
            </button>
            <button id="markGreenBtn" class="conditionBtn" style="background: linear-gradient(135deg, #28a745, #1e7e34); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🟢 Green
            </button>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px; margin-bottom: 6px;">
            <button id="markTeeBtn" class="conditionBtn" style="background: linear-gradient(135deg, #6c757d, #5a6268); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🏁 Tee
            </button>
            <button id="markFairwayBtn" class="conditionBtn" style="background: linear-gradient(135deg, #198754, #146c43); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🟩 Fairway
            </button>
            <button id="markRoughBtn" class="conditionBtn" style="background: linear-gradient(135deg, #fd7e14, #dc6502); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🌿 Rough
            </button>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 4px;">
            <button id="markHazardToolbarBtn" class="conditionBtn" style="background: linear-gradient(135deg, #dc3545, #c82333); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              ⚠️ Hazard
            </button>
            <button id="markOBToolbarBtn" class="conditionBtn" style="background: linear-gradient(135deg, #495057, #343a40); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🚫 OB
            </button>
            <button id="markRecoveryBtn" class="conditionBtn" style="background: linear-gradient(135deg, #6f42c1, #5a32a3); color: white; border: none; border-radius: 3px; padding: 4px 2px; font-size: 9px; cursor: pointer;">
              🌲 Recovery
            </button>
          </div>
          
          <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 6px;">
            <button id="clearLastBtn" style="background: linear-gradient(135deg, #ffc107, #e0a800); color: #212529; border: none; border-radius: 3px; padding: 4px; font-size: 9px; cursor: pointer;">
              ↶ Clear Last
            </button>
            <button id="clearAllConditionsBtn" style="background: linear-gradient(135deg, #e74c3c, #c0392b); color: white; border: none; border-radius: 3px; padding: 4px; font-size: 9px; cursor: pointer;">
              🗑️ Clear All
            </button>
          </div>
        </div>
        
        <!-- Optimization Controls -->
        <div style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
          <div style="font-size: 11px; font-weight: 600; margin-bottom: 6px; color: #495057;">Aim Point Optimization</div>
          
          <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px;">
            <label style="font-size: 10px; flex: 1;">Max Drive (Carry):</label>
            <input id="maxDriveToolbar" type="number" value="300" min="55" max="440" step="5" 
                   style="width: 50px; padding: 2px 4px; border: 1px solid #ddd; border-radius: 3px; font-size: 10px;" />
            <span id="maxDriveUnitsToolbar" style="font-size: 10px; color: #666;">yards</span>
          </div>
          
          <button id="optimizeToolbarBtn" style="width: 100%; background: linear-gradient(135deg, #007bff, #0056b3); color: white; border: none; border-radius: 3px; padding: 6px; font-size: 10px; cursor: pointer; margin-bottom: 6px;">
            🎯 Optimize Aim Point
          </button>
          
          <button id="clearOptimizationToolbarBtn" style="width: 100%; background: linear-gradient(135deg, #6c757d, #545b62); color: white; border: none; border-radius: 3px; padding: 4px; font-size: 9px; cursor: pointer;">
            Clear Results
          </button>
        </div>
        
        <!-- Optimization Results -->
        <div id="optimizationResultsToolbar" style="display: none; padding: 8px; background: #e8f5e8; border-radius: 6px; border: 1px solid #c3e6cb;">
          <div style="font-size: 11px; font-weight: 600; margin-bottom: 4px; color: #155724;">Optimization Results:</div>
          <div id="candidatesListToolbar" style="font-size: 9px; line-height: 1.3;"></div>
          <div style="margin-top: 4px; font-size: 9px; color: #6c757d;">Click numbered markers to select aim point</div>
        </div>
        
        <!-- Current Drawing Status -->
        <div id="drawingStatus" style="display: none; margin-top: 8px; padding: 6px; background: #fff3cd; border-radius: 4px; border: 1px solid #ffeaa7;">
          <div style="font-size: 10px; font-weight: 600; color: #856404;">Drawing Mode Active</div>
          <div id="drawingInstructions" style="font-size: 9px; color: #856404; margin-top: 2px;"></div>
          <button id="finishDrawingBtn" style="width: 100%; margin-top: 4px; background: linear-gradient(135deg, #28a745, #1e7e34); color: white; border: none; border-radius: 3px; padding: 4px; font-size: 9px; cursor: pointer;">
            ✅ Finish Drawing
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <div id="toolbar">
    <h3>Shot Analysis</h3>
    
    <div id="shotTypeSelection" style="display: none; margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 6px; border: 1px solid #e9ecef;">
      <div style="margin-bottom: 6px; font-size: 12px; font-weight: 600; color: #495057;">Shot Type</div>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
        <button id="approachShotBtn" class="toolBtn" style="font-size: 10px; padding: 4px 0;">Approach Shot</button>
        <button id="teeShotBtn" class="toolBtn" style="font-size: 10px; padding: 4px 0;">Tee Shot</button>
      </div>
    </div>

    <button id="launchBtn" class="toolBtn">Place Tee Position</button>
    <button id="pinBtn" class="toolBtn">Place Pin</button>
    <button id="selectBtn" class="toolBtn">Place Aim Point</button>
    <button id="camBtn" class="toolBtn">Refocus View</button>
    <button id="shotPovBtn" class="toolBtn">Shot POV</button>
    <button id="clearBtn" class="toolBtn">Clear All Points</button>

    <div class="toolbar-row">
      <div class="distance-display">
        <div class="display-label">Distance from Start to Pin</div>
        <div id="shotDistDisplay" class="distance-value">--</div>
      </div>
      <div class="distance-display">
        <div class="display-label">Intended Shot Distance</div>
        <div id="intendedDistDisplay" class="distance-value">--</div>
      </div>
    </div>
    
    <div class="toolbar-row">
      <div class="distance-display">
        <div class="display-label">Avg Proximity to Hole</div>
        <div id="avgDistDisplay" class="distance-value">--</div>
      </div>
    </div>

    <label>Skill level
      <select id="skillSelect">
        <option value="pro">Pro (5.3° / ±3.7%)</option>
        <option value="elite" selected>Elite Amateur (5.9° / ±4.4%)</option>
        <option value="scratch">Scratch (6.4° / ±4.9%)</option>
        <option value="good">Good Golfer (6.9° / ±5.5%)</option>
        <option value="average">Average Golfer (7.7° / ±6.1%)</option>
        <option value="bad">Bad Golfer (11.2° / ±7.2%)</option>
        <option value="terrible">Terrible Golfer (14° / ±8.4%)</option>
        <option value="jack">Jack Sonne (custom params)</option>
      <option value="custom">Custom (manual)</option>
      </select>
    </label>

    <label>Roll conditions
      <select id="rollSelect">
        <option value="no" selected>No</option>
        <option value="soft">Soft conditions</option>
        <option value="medium">Medium conditions</option>
        <option value="firm">Firm conditions</option>
        <option value="very-firm">Very firm conditions</option>
      </select>
    </label>

    <label id="jackParams" style="display:none">Offline (deg)
      <input id="jackOffline" type="number" value="6.0" step="0.1" />
    </label>
    <label id="jackParamsPct" style="display:none">Distance %
      <input id="jackDistPct" type="number" value="5.0" step="0.1" />
    </label>

    <label style="margin-top:8px; display:flex; align-items:center; gap:6px; font-size:13px;">
      <input type="checkbox" id="toggleSamples" checked style="transform:scale(1.2);"/>
      Show sample points
    </label>
    
    <label style="margin-top:8px; display:flex; align-items:center; gap:6px; font-size:13px;">
      <input type="checkbox" id="toggleUnits" checked style="transform:scale(1.2);"/>
      Display in yards
    </label>
    

    <div style="margin-top: 16px; padding-top: 12px; border-top: 1px solid #ddd;">
      <h4 style="margin: 0 0 8px; font-size: 14px; font-weight: 600; color: #2c3e50;">Slope Analysis</h4>
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 8px;">
        <label style="display:flex; align-items:center; gap:4px; font-size:12px;">
          <input type="checkbox" id="showSlopeArrows" checked style="transform:scale(1.1);"/>
          Slope arrows
        </label>
        <label style="display:flex; align-items:center; gap:4px; font-size:12px;">
          <input type="checkbox" id="showElevationDots" style="transform:scale(1.1);"/>
          Elevation dots
        </label>
      </div>
      
      <label style="display:flex; align-items:center; gap:6px; font-size:12px; margin-top: 8px; padding-top: 8px; border-top: 1px solid #eee;">
        <input type="checkbox" id="advancedShortGame" style="transform:scale(1.1);"/>
        <span style="font-weight: 500;">Advanced short game (≤45yd)</span>
        <span style="color: #666; font-size: 10px; margin-left: 4px;" title="Applies 144-combination modifiers for ball lie, green slope, elevation change, and green percentage for shots within 45 yards of the pin">ⓘ</span>
      </label>
      <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
        Grid step (m) 
        <input id="slopeStep" type="number" value="1.5" min="0.1" step=".5" style="width: 50px; padding: 2px 4px; border: 1px solid #ddd; border-radius: 3px; font-size: 11px;" />
      </label>
    </div>
  </div>


  
  <script>
  (async () => {
    try {
      console.log('=== OPTIMIZED SCRIPT STARTING ===');
      
      // Initialize performance manager and components
      window.performanceManager.initializeWorkers();
      
      // Show loading indicator
      const loadingIndicator = document.getElementById('loadingIndicator');
      const progressFill = document.getElementById('progressFill');
      const loadingMessage = document.getElementById('loadingMessage');
      
      function showLoading(message = 'Loading...') {
        loadingIndicator.style.display = 'block';
        loadingMessage.textContent = message;
      }
      
      function updateProgress(progress, message) {
        progressFill.style.width = (progress * 100) + '%';
        loadingMessage.textContent = message;
      }
      
      function hideLoading() {
        loadingIndicator.style.display = 'none';
      }
      
      showLoading('Initializing Cesium...');
      
      // Initialize Cesium
      Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIwM2RkYmZmMi0wOGU5LTQ3ZmItOGY3Yy01YWI0OGM2NDQzMjEiLCJpZCI6MzE3NDQwLCJpYXQiOjE3NTEzNzQ2NDl9.PzVT68ZKLTu3i2sfPSARSx6FfEfoF5n0GMW1FeCIieg";
      
      const viewer = new Cesium.Viewer('cesiumContainer', {
        terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(1),
        baseLayerPicker: false,
        sceneModePicker: false,
        animation: false,
        timeline: false,
        selectionIndicator: false,
        infoBox: false
      });

      // Disable entity selection behavior
      viewer.selectedEntity = undefined;
      viewer.trackedEntity = undefined;
      
      // Prevent any future selections by immediately clearing them
      viewer.selectedEntityChanged.addEventListener(() => {
        if (viewer.selectedEntity) {
          viewer.selectedEntity = undefined;
        }
      });
      
      // Prevent camera tracking
      viewer.trackedEntityChanged.addEventListener(() => {
        if (viewer.trackedEntity) {
          viewer.trackedEntity = undefined;
        }
      });
      
      // Initialize managers
      const courseDataManager = new CourseDataManager(viewer);
      window.courseDataManager = courseDataManager; // Make globally accessible
      
      courseDataManager.initializeLayers();
      
      // Course selection and loading
      const courseSelect = document.getElementById('courseSelect');
      const courseSearch = document.getElementById('courseSearch');
      const searchBtn = document.getElementById('searchBtn');
      const searchResults = document.getElementById('searchResults');
      
      const storedCourse = localStorage.getItem('selectedCourse');
      console.log('Stored course from localStorage:', storedCourse);
      if (storedCourse) {
        // Try to set the stored course
        courseSelect.value = storedCourse;
        console.log('Set courseSelect.value to:', courseSelect.value);
        console.log('Available options in dropdown:', Array.from(courseSelect.options).map(opt => `${opt.value}: ${opt.text}`));
        
        // If the stored course isn't in the dropdown (courseSelect.value is empty), 
        // it means it was from a search result that got lost on reload
        if (courseSelect.value === '' && storedCourse.trim() !== '') {
          console.log('Stored course not found in dropdown - attempting to recreate from search...');
          
          // Try to get the course name from localStorage as well
          const storedCourseName = localStorage.getItem('selectedCourseName');
          if (storedCourseName) {
            console.log('Found stored course name:', storedCourseName);
            // Add the missing option back to the dropdown
            const option = new Option(storedCourseName, storedCourse);
            courseSelect.add(option);
            courseSelect.value = storedCourse;
            console.log('Recreated option and selected course:', storedCourse);
          } else {
            console.log('No stored course name found - will need to search again');
            // Clear the invalid stored course
            localStorage.removeItem('selectedCourse');
          }
        }
      }
      
      courseSelect.addEventListener('change', () => {
        if (courseSelect.value) {
          localStorage.setItem('selectedCourse', courseSelect.value);
          // Clear any stored course name since this is a hardcoded option
          localStorage.removeItem('selectedCourseName');
          location.reload();
        }
      });
      
      // Course search functionality
      async function searchCourses() {
        const searchTerm = courseSearch.value.trim();
        if (!searchTerm) return;
        
        searchBtn.textContent = 'Searching...';
        searchBtn.disabled = true;
        searchResults.style.display = 'none';
        
        try {
          const courses = await courseDataManager.searchCoursesByName(searchTerm);
          displaySearchResults(courses);
        } catch (error) {
          console.error('Search failed:', error);
          searchResults.innerHTML = '<div style="padding: 8px; color: red; font-size: 11px;">Search failed. Please try again.</div>';
          searchResults.style.display = 'block';
        }
        
        searchBtn.textContent = 'Search Courses';
        searchBtn.disabled = false;
      }
      
      function displaySearchResults(courses) {
        if (courses.length === 0) {
          searchResults.innerHTML = '<div style="padding: 8px; color: #666; font-size: 11px;">No courses found.</div>';
          searchResults.style.display = 'block';
          return;
        }
        
        const resultsHtml = courses.map(course => `
          <div class="search-result" data-course-id="${course.id}" style="
            padding: 6px 8px; 
            border-bottom: 1px solid #eee; 
            cursor: pointer; 
            font-size: 11px;
            hover: background: #f5f5f5;
          " onmouseover="this.style.background='#f5f5f5'" onmouseout="this.style.background='white'">
            <div style="font-weight: 600; color: #333;">${course.name}</div>
            <div style="color: #666; font-size: 10px;">
              ${[course.city, course.state, course.country].filter(x => x).join(', ')}
            </div>
          </div>
        `).join('');
        
        searchResults.innerHTML = resultsHtml;
        searchResults.style.display = 'block';
        
        // Add click handlers to search results
        document.querySelectorAll('.search-result').forEach(result => {
          result.addEventListener('click', () => {
            const courseId = result.dataset.courseId;
            const courseName = result.querySelector('div').textContent;
            console.log('Search result clicked - Course ID:', courseId, 'Name:', courseName);
            
            // Add to dropdown if not already present
            const existingOption = Array.from(courseSelect.options).find(opt => opt.value === courseId);
            if (!existingOption) {
              const option = new Option(courseName, courseId);
              courseSelect.add(option);
              console.log('Added new option to dropdown:', courseId, courseName);
            } else {
              console.log('Option already exists in dropdown');
            }
            
            // Select the course
            courseSelect.value = courseId;
            localStorage.setItem('selectedCourse', courseId);
            localStorage.setItem('selectedCourseName', courseName); // Store name for recreation
            console.log('Stored in localStorage - ID:', courseId, 'Name:', courseName);
            console.log('courseSelect.value after setting:', courseSelect.value);
            searchResults.style.display = 'none';
            courseSearch.value = '';
            
            // Load the course
            console.log('Reloading page...');
            location.reload();
          });
        });
      }
      
      // Event listeners
      searchBtn.addEventListener('click', searchCourses);
      courseSearch.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          searchCourses();
        }
      });
      
      // Course selection toggle functionality
      const toggleCourseSelectionBtn = document.getElementById('toggleCourseSelection');
      const courseSelectionContent = document.getElementById('courseSelectionContent');
      let courseSelectionCollapsed = false;
      
      toggleCourseSelectionBtn.addEventListener('click', () => {
        courseSelectionCollapsed = !courseSelectionCollapsed;
        
        if (courseSelectionCollapsed) {
          courseSelectionContent.classList.add('collapsed');
          toggleCourseSelectionBtn.classList.add('collapsed');
          toggleCourseSelectionBtn.textContent = '▶';
        } else {
          courseSelectionContent.classList.remove('collapsed');
          toggleCourseSelectionBtn.classList.remove('collapsed');
          toggleCourseSelectionBtn.textContent = '▼';
        }
      });
      
      // Hole navigation toggle functionality
      const toggleHoleNavigationBtn = document.getElementById('toggleHoleNavigation');
      const holeNavigationContent = document.getElementById('holeNavigationContent');
      let holeNavigationCollapsed = false;
      
      toggleHoleNavigationBtn.addEventListener('click', () => {
        holeNavigationCollapsed = !holeNavigationCollapsed;
        
        if (holeNavigationCollapsed) {
          holeNavigationContent.classList.add('collapsed');
          toggleHoleNavigationBtn.classList.add('collapsed');
          toggleHoleNavigationBtn.textContent = '▶';
        } else {
          holeNavigationContent.classList.remove('collapsed');
          toggleHoleNavigationBtn.classList.remove('collapsed');
          toggleHoleNavigationBtn.textContent = '▼';
        }
      });
      
      // Only load course data if a course is selected
      const courseIds = courseSelect.value;
      let courseFeatures = {};
      
      if (courseIds && courseIds.trim() !== '') {
        // Load course data with progress tracking
        await courseDataManager.loadCourse(courseIds, (progress) => {
          updateProgress(progress.progress, progress.message);
        });
        
        // Get course features for analysis
        courseFeatures = courseDataManager.getCourseFeatures();
      } else {
        console.log('No course selected - skipping course data loading');
      }
      
      hideLoading();
      
      // Slope visualization state
      let slopeArrowDS = new Cesium.CustomDataSource("slopeArrows");
      viewer.dataSources.add(slopeArrowDS);
      let slopeDots = viewer.scene.primitives.add(new Cesium.PointPrimitiveCollection());
      
      let currentHoleId = null;
      let currentHolePath = null;
      let currentGreenPoly = null;
      
      const showSlopeArrowsEl = document.getElementById('showSlopeArrows');
      const showElevationDotsEl = document.getElementById('showElevationDots');
      const slopeStepEl = document.getElementById('slopeStep');

      // Utility functions
      function cartToDeg(c) {
        const cc = Cesium.Cartographic.fromCartesian(c);
        return [Cesium.Math.toDegrees(cc.longitude), Cesium.Math.toDegrees(cc.latitude), cc.height||0];
      }

      // Advanced Short Game Analysis Functions
      
      // Analyze ball lie based on terrain slope at ball position
      function analyzeBallLie(ballLon, ballLat, ballZ, globe) {
        try {
          const stepM = 1.0; // Small step for slope calculation
          const earthRadius = 6371000;
          const mLat = earthRadius * Math.PI / 180;
          const mLon = earthRadius * Math.cos(ballLat * Math.PI / 180) * Math.PI / 180;
          
          const stepDegLat = stepM / mLat;
          const stepDegLon = stepM / mLon;
          
          // Sample heights around ball position using cached function
          const heightN = sampleTerrainCached(globe, ballLon, ballLat + stepDegLat);
          const heightS = sampleTerrainCached(globe, ballLon, ballLat - stepDegLat);
          const heightE = sampleTerrainCached(globe, ballLon + stepDegLon, ballLat);
          const heightW = sampleTerrainCached(globe, ballLon - stepDegLon, ballLat);
          
          // Calculate slope vector
          const slopeX = (heightE - heightW) / (2 * stepM);
          const slopeY = (heightN - heightS) / (2 * stepM);
          const slopeMagnitude = Math.sqrt(slopeX * slopeX + slopeY * slopeY);
          const slopePercent = slopeMagnitude * 100;
          
          // Calculate slope angle in degrees
          const slopeAngle = Math.atan(slopeMagnitude) * 180 / Math.PI;
          
          // Determine primary slope direction (≥2% threshold for "noticeable")
          if (slopePercent < 2.0) {
            return { category: 'flat', angle: slopeAngle, display: `${slopeAngle.toFixed(1)}° flat` };
          }
          
          // Determine if slope is primarily uphill, downhill, or sidehill relative to pin
          const absX = Math.abs(slopeX);
          const absY = Math.abs(slopeY);
          
          // Debug slope components for first few calculations
          if (!window.ballLieDebugCount || window.ballLieDebugCount <= 3) {
            window.ballLieDebugCount = (window.ballLieDebugCount || 0) + 1;
            console.log(`🔍 BALL LIE DEBUG #${window.ballLieDebugCount}:`);
            console.log(`   slopeX (E-W): ${slopeX.toFixed(4)}, absX: ${absX.toFixed(4)}`);
            console.log(`   slopeY (N-S): ${slopeY.toFixed(4)}, absY: ${absY.toFixed(4)}`);
            console.log(`   absY > absX: ${absY > absX} (${absY.toFixed(4)} > ${absX.toFixed(4)})`);
          }
          
          let category;
          if (absY > absX) {
            // Reverse by 180 degrees: flip uphill/downhill
            category = slopeY > 0 ? 'downhill' : 'uphill';
          } else {
            category = 'sidehill';
          }
          
          return { category: category, angle: slopeAngle, display: `${slopeAngle.toFixed(1)}° ${category}` };
        } catch (error) {
          console.warn('Error analyzing ball lie:', error);
          return { category: 'flat', angle: 0, display: '0.0° flat' };
        }
      }
      
      // Analyze green slope along ball-to-pin line
      function analyzeGreenSlope(ballLon, ballLat, ballZ, pinLon, pinLat, pinZ, globe, greenPoly) {
        try {
          // Calculate ball-to-pin direction
          const dx = pinLon - ballLon;
          const dy = pinLat - ballLat;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance === 0) return { category: 'flat', angle: 0, display: '0.0° flat' };
          
          // Sample terrain along line from ball to pin (focusing on green area) - reduced for performance
          const numSamples = 2;
          let totalSlope = 0;
          let validSamples = 0;
          
          for (let i = 1; i <= numSamples; i++) {
            const t = i / (numSamples + 1);
            const sampleLon = ballLon + dx * t;
            const sampleLat = ballLat + dy * t;
            
            // Check if sample point is on/near green
            if (greenPoly && !pointInPolyDeg(sampleLon, sampleLat, greenPoly.map(p => [p[0], p[1]]))) {
              continue;
            }
            
            const sampleHeight = sampleTerrainCached(globe, sampleLon, sampleLat);
            
            // Calculate slope toward pin
            const prevT = Math.max(0, (i-1) / (numSamples + 1));
            const prevLon = ballLon + dx * prevT;
            const prevLat = ballLat + dy * prevT;
            const prevHeight = sampleTerrainCached(globe, prevLon, prevLat);
            
            const segmentDistance = distance * (1 / (numSamples + 1));
            const earthRadius = 6371000;
            const mLat = earthRadius * Math.PI / 180;
            const segmentMeters = segmentDistance * mLat;
            
            const slope = (sampleHeight - prevHeight) / segmentMeters;
            totalSlope += slope;
            validSamples++;
          }
          
          if (validSamples === 0) {
            // Debug why no valid samples found
            if (window.greenSlopeDebugCount <= 3) {
              window.greenSlopeDebugCount = (window.greenSlopeDebugCount || 0) + 1;
              console.log(`⚠️ GREEN SLOPE DEBUG: No valid samples found`);
              console.log(`   Green polygon: ${greenPoly ? greenPoly.length + ' points' : 'null'}`);
              console.log(`   NumSamples attempted: ${numSamples}`);
            }
            return { category: 'flat', angle: 0, display: '0.0° flat (no green samples)' };
          }
          
          const avgSlope = totalSlope / validSamples;
          const slopePercent = Math.abs(avgSlope) * 100;
          const slopeAngle = Math.atan(Math.abs(avgSlope)) * 180 / Math.PI;
          
          if (slopePercent < 2.0) {
            return { category: 'flat', angle: slopeAngle, display: `${slopeAngle.toFixed(1)}° flat` };
          }
          
          // Determine if green runs toward or away from player
          const category = avgSlope > 0 ? 'uphill' : 'downhill';
          return { category: category, angle: slopeAngle, display: `${slopeAngle.toFixed(1)}° ${category}` };
          
        } catch (error) {
          console.warn('Error analyzing green slope:', error);
          return { category: 'flat', angle: 0, display: '0.0° flat' };
        }
      }
      
      // Analyze elevation change from ball to pin
      function analyzeElevationChange(ballZ, pinZ) {
        const elevationDiff = pinZ - ballZ;
        const elevationAngle = Math.atan(Math.abs(elevationDiff) / 30) * 180 / Math.PI; // Assume 30m average distance for angle calc
        
        // Debug elevation values
        if (window.debugShortGameCount <= 10) {
          console.log(`📏 ELEVATION DEBUG: Ball=${ballZ.toFixed(1)}m, Pin=${pinZ.toFixed(1)}m, Diff=${elevationDiff.toFixed(1)}m`);
        }
        
        if (Math.abs(elevationDiff) < 1.0) {
          return { category: 'flat', diff: elevationDiff, display: `${elevationDiff.toFixed(1)}m flat` };
        }
        
        const category = elevationDiff > 0 ? 'uphill' : 'downhill';
        return { category: category, diff: elevationDiff, display: `${elevationDiff.toFixed(1)}m ${category}` };
      }
      
      // Calculate green percentage (short-sidedness) for landing area analysis
      function calculateGreenPercentage(ballLon, ballLat, pinLon, pinLat, greenPoly) {
        try {
          if (!greenPoly || greenPoly.length < 3) {
            console.log('⚠️ No green polygon data available');
            return { category: '<20%', percentage: 10, display: '10% green available (no green data)' }; // Default to very short-sided if no green data
          }
          
          // Calculate ball-to-pin distance
          const earthRadius = 6371000;
          const mLat = earthRadius * Math.PI / 180;
          const mLon = earthRadius * Math.cos(ballLat * Math.PI / 180) * Math.PI / 180;
          
          const dx = (pinLon - ballLon) * mLon;
          const dy = (pinLat - ballLat) * mLat;
          const ballToPinDistance = Math.sqrt(dx * dx + dy * dy);
          
          if (ballToPinDistance === 0) return { category: '>45%', percentage: 90, display: '90% green available' };
          
          // Simple approach: Sample points from ball to pin, find last point that's on green
          const numSamples = 50; // High resolution for accuracy
          let lastGreenDistance = 0;
          let foundAnyGreen = false;
          
          // Reset debug counter and always show debug for first calculation in each session
          if (!window.greenDebugReset) {
            window.greenDebugCount = 0;
            window.greenDebugReset = true;
          }
          
          const showDebug = window.greenDebugCount < 5; // Show more debug info
          if (showDebug) {
            window.greenDebugCount++;
            console.log(`🔍 GREEN DETECTION DEBUG #${window.greenDebugCount}:`);
            console.log(`   Ball at (${ballLon.toFixed(6)}, ${ballLat.toFixed(6)})`);
            console.log(`   Pin at (${pinLon.toFixed(6)}, ${pinLat.toFixed(6)})`);
            console.log(`   Total distance: ${(ballToPinDistance * 1.09361).toFixed(1)} yards`);
            console.log(`   Green polygon points: ${greenPoly ? greenPoly.length : 'none'}`);
            if (greenPoly && greenPoly.length > 0) {
              console.log(`   First green point: (${greenPoly[0][0].toFixed(6)}, ${greenPoly[0][1].toFixed(6)})`);
              // Test if pin is in green
              const pinInGreen = pointInPolyDeg(pinLon, pinLat, greenPoly.map(p => [p[0], p[1]]));
              console.log(`   Pin in green: ${pinInGreen}`);
            } else {
              console.log(`   🚨 GREEN POLYGON IS NULL OR EMPTY!`);
            }
          }
          
          // New approach: Sample points from ball to pin and find the LAST point that's on green
          // This gives us the distance from ball to the edge of green closest to pin
          
          console.log(`🔍 TRYING USER'S APPROACH: Sampling ${numSamples} points from ball to pin...`);
          
          for (let i = 0; i <= numSamples; i++) {
            const t = i / numSamples;
            const sampleLon = ballLon + (pinLon - ballLon) * t;
            const sampleLat = ballLat + (pinLat - ballLat) * t;
            
            // Use the same green detection method that's working for the main point detection
            let inGreen = false;
            
            // Try multiple green detection methods
            if (greenPoly && greenPoly.length >= 3) {
              try {
                inGreen = pointInPolyDeg(sampleLon, sampleLat, greenPoly.map(p => [p[0], p[1]]));
              } catch(e) {
                console.log(`   Point-in-polygon error: ${e.message}`);
              }
            }
            
            // Alternative: Use the same green detection method as the main system (which is working)
            if (!inGreen && courseFeatureCache && courseFeatureCache.greenPolygon) {
              try {
                inGreen = pointInPolyDeg(sampleLon, sampleLat, courseFeatureCache.greenPolygon);
                if (inGreen && showDebug) {
                  console.log(`   🔄 Found via courseFeatureCache.greenPolygon fallback`);
                }
              } catch(e) {
                console.log(`   Cache fallback error: ${e.message}`);
              }
            }
            
            if (inGreen) {
              lastGreenDistance = ballToPinDistance * t; // Distance from ball to this green point
              foundAnyGreen = true;
              
              if (showDebug && (i % 10 === 0 || i === numSamples)) {
                console.log(`   ✅ Sample ${i}: t=${t.toFixed(2)} ON GREEN, dist=${(lastGreenDistance * 1.09361).toFixed(1)}y from ball`);
              }
            } else if (showDebug && (i % 5 === 0)) {
              console.log(`   ❌ Sample ${i}: t=${t.toFixed(2)} NOT on green`);
            }
          }
          
          console.log(`🎯 SAMPLING COMPLETE: Found green=${foundAnyGreen}, last green distance=${(lastGreenDistance * 1.09361).toFixed(1)}y`);
          
          if (!foundAnyGreen) {
            if (showDebug) {
              console.log(`🚫 NO GREEN FOUND along ball-to-pin line!`);
              console.log(`   This suggests ball is not aimed at green or green polygon is incorrect`);
            }
            return { category: '<20%', percentage: 0, display: 'No green found on target line' };
          }
          
          // Distance from last green point to pin = usable green depth
          const usableGreenDepth = ballToPinDistance - lastGreenDistance;
          
          // Calculate green percentage
          const greenPercent = Math.max(0, (usableGreenDepth / ballToPinDistance) * 100);
          
          // Convert distances to yards for display
          const ballToPinYards = ballToPinDistance * 1.09361;
          const usableGreenYards = usableGreenDepth * 1.09361;
          
          // Categorize according to documentation thresholds
          let category;
          if (greenPercent < 20) {
            category = '<20%';
          } else if (greenPercent <= 45) {
            category = '20-45%';
          } else {
            category = '>45%';
          }
          
          // Debug output for green percentage calculation
          if (showDebug) {
            console.log(`🟢 GREEN CALCULATION RESULT:`);
            console.log(`   Shot Distance: ${ballToPinYards.toFixed(1)} yards`);
            console.log(`   Last Green Point: ${(lastGreenDistance * 1.09361).toFixed(1)} yards from ball`);
            console.log(`   Usable Green Depth: ${usableGreenYards.toFixed(1)} yards`);
            console.log(`   Green Percentage: ${greenPercent.toFixed(1)}% (${category})`);
            console.log(`   Found Green: ${foundAnyGreen ? 'Yes' : 'No'}`);
          }
          
          return { 
            category: category, 
            percentage: greenPercent, 
            display: `${greenPercent.toFixed(0)}% green available (${usableGreenYards.toFixed(1)}y of ${ballToPinYards.toFixed(1)}y total)` 
          };
          
        } catch (error) {
          console.warn('Error calculating green percentage:', error);
          return { category: '<20%', percentage: 5, display: '5% green available (error in calculation)' }; // Default to most conservative estimate
        }
      }
      
      // Calculate advanced expected strokes with short game modifiers
      function calculateAdvancedExpectedStrokes(distance, baseExpectedStrokes, ballLon, ballLat, ballZ, pinLon, pinLat, pinZ, globe, greenPoly) {
        try {
          // Only apply advanced modifiers for shots ≤ 45 yards
          if (distance > 45.0) {
            return baseExpectedStrokes;
          }
          
          // Get advanced short game toggle state
          const toggle = document.getElementById('advancedShortGame');
          if (!toggle || !toggle.checked) {
            return baseExpectedStrokes;
          }
          
          // Analyze all four conditions
          const globe = viewer.scene.globe;
          const ballLie = analyzeBallLie(ballLon, ballLat, ballZ, globe);
          const greenSlope = analyzeGreenSlope(ballLon, ballLat, ballZ, pinLon, pinLat, pinZ, globe, greenPoly);
          const elevationChange = analyzeElevationChange(ballZ, pinZ);
          const greenPercent = calculateGreenPercentage(ballLon, ballLat, pinLon, pinLat, greenPoly);
          
          // Debug: Print first few analysis results
          if (distance <= 45.0) {
            window.debugShortGameCount = (window.debugShortGameCount || 0) + 1;
            if (window.debugShortGameCount <= 3) {
              console.log(`DEBUG Advanced Analysis ${window.debugShortGameCount}:`);
              console.log(`  Ball: (${ballLon.toFixed(6)}, ${ballLat.toFixed(6)}, ${ballZ.toFixed(1)})`);
              console.log(`  Pin: (${pinLon.toFixed(6)}, ${pinLat.toFixed(6)}, ${pinZ.toFixed(1)})`);
              console.log(`  Results: ${ballLie.category} | ${greenSlope.category} | ${elevationChange.category} | ${greenPercent.category}`);
            }
          }
          
          // Get modifier and color from lookup table
          const result = getShortGameModifierAndColor(ballLie, greenSlope, elevationChange, greenPercent);
          const modifier = result.modifier;
          
          // Apply modifier to base expected strokes
          const advancedExpectedStrokes = baseExpectedStrokes + modifier;
          
          // Ensure result is not negative
          return Math.max(0.1, advancedExpectedStrokes);
          
        } catch (error) {
          console.warn('Error calculating advanced expected strokes:', error);
          return baseExpectedStrokes; // Fallback to base calculation
        }
      }
      
      // Advanced short game colors are now pre-computed in the JSON lookup table

      function getCorrectHoleOrientation(holeNum, holePath) {
        const greenPoly = courseFeatures.greenMap.get(String(holeNum));
        
        if (!holePath || holePath.length < 2) {
          return { tee: holePath?.[0], green: holePath?.[holePath.length - 1], reversed: false };
        }
        
        const start = holePath[0];
        const end = holePath[holePath.length - 1];
        
        if (!greenPoly) {
          return { tee: start, green: end, reversed: false };
        }
        
        const greenCenter = getPolygonCenter(greenPoly);
        const startToGreen = Cesium.Cartesian3.distance(start, greenCenter);
        const endToGreen = Cesium.Cartesian3.distance(end, greenCenter);
        
        if (endToGreen < startToGreen) {
          return { tee: start, green: end, reversed: false };
        } else {
          return { tee: end, green: start, reversed: true };
        }
      }
      
      function getPolygonCenter(polygon) {
        let sumX = 0, sumY = 0, sumZ = 0;
        for (const point of polygon) {
          sumX += point.x;
          sumY += point.y; 
          sumZ += point.z;
        }
        return new Cesium.Cartesian3(sumX / polygon.length, sumY / polygon.length, sumZ / polygon.length);
      }
      
      // Calculate hole length in yards and determine shot type availability
      function calculateHoleLengthAndType(holeId) {
        const greenPoly = courseFeatures.greenMap.get(String(holeId));
        const holePath = courseFeatures.holeMap.get(String(holeId));
        
        if (!greenPoly || !holePath || holePath.length < 2) {
          return { lengthYards: 0, isShortHole: true };
        }
        
        const orientation = getCorrectHoleOrientation(holeId, holePath);
        const tee = orientation.tee;
        const green = orientation.green;
        
        const holeLengthMeters = Cesium.Cartesian3.distance(tee, green);
        const holeLengthYards = holeLengthMeters * 1.09361; // Convert meters to yards
        const isShortHole = holeLengthYards < 300;
        
        return { lengthYards: holeLengthYards, isShortHole: isShortHole };
      }
      
      // Update shot type UI based on hole length
      function updateShotTypeUI(holeId) {
        const { lengthYards, isShortHole } = calculateHoleLengthAndType(holeId);
        currentHoleLength = lengthYards;
        
        if (isShortHole) {
          // Short holes: Hide shot type selection, always use tee-to-green
          shotTypeSelection.style.display = 'none';
          currentShotType = 'tee';
          updateShotTypeButtons();
          console.log(`Short hole (${lengthYards.toFixed(0)} yards): Tee-to-green shot only`);
        } else {
          // Long holes: Show shot type selection, default to tee shot
          shotTypeSelection.style.display = 'block';
          currentShotType = 'tee';
          updateShotTypeButtons();
          console.log(`Long hole (${lengthYards.toFixed(0)} yards): Shot type selection available, defaulting to tee shot`);
        }
      }
      
      // Update shot type button styles
      function updateShotTypeButtons() {
        console.log(`Updating shot type buttons: currentShotType = ${currentShotType}`);
        if (currentShotType === 'approach') {
          approachShotBtn.classList.add('active');
          teeShotBtn.classList.remove('active');
          console.log('Set approach button as active');
        } else {
          teeShotBtn.classList.add('active');
          approachShotBtn.classList.remove('active');
          console.log('Set tee shot button as active');
        }
      }
      
      // Set marker positions based on current shot type
      async function setPositionsForShotType(greenLon, greenLat, greenHeight, fairwayLon, fairwayLat, fairwayHeight, teeLon, teeLat, teeHeight) {
        console.log(`setPositionsForShotType called with currentShotType: ${currentShotType}`);
        console.log(`Green: (${greenLon.toFixed(4)}, ${greenLat.toFixed(4)}), Fairway: (${fairwayLon.toFixed(4)}, ${fairwayLat.toFixed(4)}), Tee: (${teeLon.toFixed(4)}, ${teeLat.toFixed(4)})`);
        
        if (currentShotType === 'tee') {
          // Tee shot: Tee center → Green center (short holes) OR Tee center → Fairway midpoint (long holes)
          if (currentHoleLength < 300) {
            // Short hole: Tee to green
            console.log(`TEE SHOT (Short): Placing pin at green center (${greenLon.toFixed(4)}, ${greenLat.toFixed(4)})`);
            await placePin(greenLon, greenLat, greenHeight);
            centerLon = greenLon;
            centerLat = greenLat;
            console.log('Short hole: Tee-to-green shot');
          } else {
            // Long hole tee shot: Tee to fairway midpoint
            console.log(`TEE SHOT (Long): Placing pin at fairway midpoint (${fairwayLon.toFixed(4)}, ${fairwayLat.toFixed(4)})`);
            await placePin(fairwayLon, fairwayLat, fairwayHeight);
            centerLon = fairwayLon;
            centerLat = fairwayLat;
            console.log('Long hole: Tee shot to fairway midpoint');
          }
          
          // Place tee position
          console.log(`TEE SHOT: Placing tee at tee box (${teeLon.toFixed(4)}, ${teeLat.toFixed(4)}) with CLAMP_TO_GROUND`);
          if (launchEntity) viewer.entities.remove(launchEntity);
          launchEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(teeLon, teeLat),
            point: { pixelSize: 5, color: Cesium.Color.CYAN, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, disableDepthTestDistance: 1000 }
          });
          
        } else {
          // Approach shot: Fairway midpoint → Green center
          console.log(`APPROACH SHOT: Placing pin at green center (${greenLon.toFixed(4)}, ${greenLat.toFixed(4)})`);
          await placePin(greenLon, greenLat, greenHeight);
          centerLon = greenLon;
          centerLat = greenLat;
          
          // Place tee position at fairway midpoint
          console.log(`APPROACH SHOT: Placing tee at fairway midpoint (${fairwayLon.toFixed(4)}, ${fairwayLat.toFixed(4)}) with CLAMP_TO_GROUND`);
          if (launchEntity) viewer.entities.remove(launchEntity);
          launchEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(fairwayLon, fairwayLat),
            point: { pixelSize: 5, color: Cesium.Color.CYAN, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, disableDepthTestDistance: 1000 }
          });
          console.log('Approach shot: Fairway to green - Complete');
        }
      }

      // Simplified slope analysis that actually creates visualization
      async function buildSlopeForGreen(greenPolyCart) {
        if (!greenPolyCart || greenPolyCart.length < 3) return;
        if (!showSlopeArrowsEl?.checked && !showElevationDotsEl?.checked) return;

        slopeArrowDS.entities.removeAll();
        slopeDots.removeAll();

        console.log('Building slope visualization for green...');

        try {
          // Convert poly to lon/lat (deg)
          const polyDeg = greenPolyCart.map(cartToDeg).map(([lon, lat]) => [lon, lat]);
          
          // BBox with buffer
          const lons = polyDeg.map(p => p[0]);
          const lats = polyDeg.map(p => p[1]);
          let west = Math.min(...lons), east = Math.max(...lons);
          let south = Math.min(...lats), north = Math.max(...lats);

          const extraMeters = 9.144; // 10 yards
          const latMid = (north + south) * 0.5;
          const mLat = 111132.0;
          const mLon = 111320.0 * Math.cos(Cesium.Math.toRadians(latMid));
          const dLat = extraMeters / mLat;
          const dLon = extraMeters / mLon;
          west -= dLon; east += dLon;
          south -= dLat; north += dLat;

          const stepM = Math.max(1, parseFloat(slopeStepEl.value) || 2);
          const stepDegLat = stepM / mLat;
          const stepDegLon = stepM / mLon;
          const nLat = Math.floor((north - south) / stepDegLat) + 1;
          const nLon = Math.floor((east - west) / stepDegLon) + 1;

          if (nLat < 2 || nLon < 2) return;

          // Create cartographics for terrain sampling
          const cartos = [];
          const mask = new Uint8Array(nLat * nLon);
          
          for (let i = 0; i < nLat; i++) {
            const lat = south + i * stepDegLat;
            for (let j = 0; j < nLon; j++) {
              const lon = west + j * stepDegLon;
              const idx = i * nLon + j;

              // Simple point-in-polygon check
              const inside = pointInPolyDeg(lon, lat, polyDeg);
              let ok = false;
              if (inside) {
                ok = true;
              } else {
                // Allow within 10 yards
                const d = distPointToPolyMeters(lon, lat, polyDeg, mLat, mLon);
                if (d <= extraMeters) ok = true;
              }

              if (ok) {
                mask[idx] = 1;
                cartos.push(new Cesium.Cartographic(
                  Cesium.Math.toRadians(lon), Cesium.Math.toRadians(lat), 0
                ));
              }
            }
          }

          if (cartos.length === 0) return;

          console.log(`Sampling ${cartos.length} terrain points`);
          const terrain = viewer.terrainProvider;
          const sampled = await Cesium.sampleTerrainMostDetailed(terrain, cartos);
          
          // Put heights back into a dense grid
          const heights = new Float32Array(nLat * nLon);
          heights.fill(NaN);
          let k = 0;
          for (let i = 0; i < nLat; i++) {
            for (let j = 0; j < nLon; j++) {
              const idx = i * nLon + j;
              if (mask[idx]) {
                heights[idx] = sampled[k++].height;
              }
            }
          }

          // Simple smoothing
          const smoothed = smoothGrid(heights, nLat, nLon);
          const finite = smoothed.filter(Number.isFinite);
          const hMin = finite.length ? Math.min(...finite) : 0;
          const hMax = finite.length ? Math.max(...finite) : 1;
          const hRange = Math.max(1e-6, hMax - hMin);

          // Create slope arrows and elevation dots
          const ARROW_LEN_M = 0.8 * stepM;
          const ARROW_WIDTH = 6 * 0.7 * stepM;
          const hOffset = 0.05;

          const h = (i, j) => smoothed[i * nLon + j];

          for (let i = 1; i < nLat - 1; i++) {
            const lat = south + i * stepDegLat;
            for (let j = 1; j < nLon - 1; j++) {
              const lon = west + j * stepDegLon;
              const idx = i * nLon + j;
              if (!mask[idx]) continue;

              const zc = h(i, j);
              if (!Number.isFinite(zc)) continue;
              const zL = h(i, j - 1), zR = h(i, j + 1);
              const zB = h(i - 1, j), zT = h(i + 1, j);
              if (![zL, zR, zB, zT].every(Number.isFinite)) continue;

              const dzdx = (zR - zL) / (2 * stepDegLon * mLon);
              const dzdy = (zT - zB) / (2 * stepDegLat * mLat);
              const sx = -dzdx, sy = -dzdy;
              const mag = Math.hypot(sx, sy);
              if (mag < 1e-6) continue;

              const slopePercent = mag * 100;
              let color;
              if (slopePercent < 0.5) {
                color = Cesium.Color.GRAY.withAlpha(0.4);
              } else if (slopePercent >= 12) {
                color = Cesium.Color.fromCssColorString("#800000");
              } else {
                const t = (slopePercent - 0.5) / (12 - 0.5);
                const hue = 240 * (1 - t);
                color = Cesium.Color.fromHsl(hue / 360, 1, 0.45);
              }

              const z = zc + hOffset;

              // elevation dots
              if (showElevationDotsEl?.checked) {
                const t = (zc - hMin) / hRange;
                slopeDots.add({
                  position: Cesium.Cartesian3.fromDegrees(lon, lat, z),
                  pixelSize: 4,
                  color: Cesium.Color.fromHsl(0.6 - 0.6 * t, 1, 0.5)
                });
              }

              // slope arrows
              if (showSlopeArrowsEl?.checked) {
                const scale = ARROW_LEN_M / mag;
                const dxDeg = (sx * scale) / mLon;
                const dyDeg = (sy * scale) / mLat;
                const zEnd = z - (ARROW_LEN_M * mag);

                slopeArrowDS.entities.add({
                  polyline: {
                    positions: Cesium.Cartesian3.fromRadiansArrayHeights([
                      Cesium.Math.toRadians(lon), Cesium.Math.toRadians(lat), z,
                      Cesium.Math.toRadians(lon + dxDeg), Cesium.Math.toRadians(lat + dyDeg), zEnd
                    ]),
                    width: ARROW_WIDTH,
                    material: new Cesium.PolylineArrowMaterialProperty(color),
                    clampToGround: false
                  }
                });
              }
            }
          }

          slopeArrowDS.show = showSlopeArrowsEl.checked;
          slopeDots.show = showElevationDotsEl.checked;
          
          console.log(`Slope analysis complete. Generated ${slopeArrowDS.entities.values.length} arrows, ${slopeDots.length} dots`);
          
        } catch (error) {
          console.error('Error building slope visualization:', error);
        }
      }

      // Helper functions for slope analysis
      function pointInPolyDeg(lon, lat, polyDeg2D) {
        let inside = false;
        for (let i = 0, j = polyDeg2D.length - 1; i < polyDeg2D.length; j = i++) {
          const xi = polyDeg2D[i][0], yi = polyDeg2D[i][1];
          const xj = polyDeg2D[j][0], yj = polyDeg2D[j][1];
          const intersect = ((yi > lat) !== (yj > lat)) &&
                            (lon < (xj - xi) * (lat - yi) / (yj - yi + 1e-20) + xi);
          if (intersect) inside = !inside;
        }
        return inside;
      }

      function distPointToPolyMeters(lon, lat, polyDeg2D, mLat, mLon) {
        const px = lon * mLon, py = lat * mLat;
        let best = Infinity;
        for (let i = 0, j = polyDeg2D.length - 1; i < polyDeg2D.length; j = i++) {
          const [lon1, lat1] = polyDeg2D[j];
          const [lon2, lat2] = polyDeg2D[i];
          const x1 = lon1 * mLon, y1 = lat1 * mLat;
          const x2 = lon2 * mLon, y2 = lat2 * mLat;
          const dx = x2 - x1, dy = y2 - y1;
          const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy || 1)));
          const cx = x1 + t * dx, cy = y1 + t * dy;
          const d = Math.hypot(px - cx, py - cy);
          if (d < best) best = d;
        }
        return best;
      }

      function smoothGrid(src, rows, cols) {
        const dst = new Float32Array(src.length);
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            let sum = 0, n = 0;
            for (let dr = -1; dr <= 1; dr++) {
              const rr = r + dr; if (rr < 0 || rr >= rows) continue;
              for (let dc = -1; dc <= 1; dc++) {
                const cc = c + dc; if (cc < 0 || cc >= cols) continue;
                const v = src[rr * cols + cc];
                if (Number.isFinite(v)) { sum += v; n++; }
              }
            }
            dst[r * cols + c] = n ? sum / n : NaN;
          }
        }
        return dst;
      }

      // Debounced slope refresh
      function refreshSlopeIfPossible() {
        window.performanceManager.debounce('slope-refresh', () => {
          // Always clear first
          slopeArrowDS.entities.removeAll();
          slopeDots.removeAll();
          
          // Only rebuild if checkboxes are checked
          if (currentGreenPoly && (showSlopeArrowsEl?.checked || showElevationDotsEl?.checked)) {
            buildSlopeForGreen(currentGreenPoly);
          }
          
          // Update visibility based on checkbox state
          slopeArrowDS.show = showSlopeArrowsEl?.checked || false;
          slopeDots.show = showElevationDotsEl?.checked || false;
        }, 600);
      }

      // Event listeners with debouncing
      showSlopeArrowsEl?.addEventListener('change', refreshSlopeIfPossible);
      showElevationDotsEl?.addEventListener('change', refreshSlopeIfPossible);
      slopeStepEl?.addEventListener('change', refreshSlopeIfPossible);
      
      // Advanced short game toggle event listener
      const advancedShortGameEl = document.getElementById('advancedShortGame');
      advancedShortGameEl?.addEventListener('change', () => {
        // Regenerate sample points with new color scheme and calculations
        if (sampleEntities.length > 0) {
          console.log('Advanced short game toggled, regenerating sample points...');
          generateRandomPoints();
        }
      });

      // Course features toggle
      const toggleFeaturesBtn = document.getElementById('toggleFeatures');
      let featuresVisible = false;
      
      toggleFeaturesBtn.addEventListener('click', () => {
        featuresVisible = !featuresVisible;
        courseDataManager.toggleFeatureVisibility(featuresVisible);
        toggleFeaturesBtn.textContent = featuresVisible ? 'Hide Course Features' : 'Show Course Features';
        toggleFeaturesBtn.classList.toggle('active', featuresVisible);
      });
      
      // Google 3D Tiles toggle
      const toggleGoogleTilesBtn = document.getElementById('toggleGoogleTiles');
      let googleTilesEnabled = false;
      let googleTileset = null;
      
      toggleGoogleTilesBtn.addEventListener('click', async () => {
        googleTilesEnabled = !googleTilesEnabled;
        
        if (googleTilesEnabled) {
          // Enable Google Photorealistic 3D Tiles
          try {
            console.log('Enabling Google Photorealistic 3D Tiles...');
            
            // Create Google Photorealistic 3D Tiles tileset
            if (!googleTileset) {
              googleTileset = viewer.scene.primitives.add(
                await Cesium.createGooglePhotorealistic3DTileset()
              );
            } else {
              googleTileset.show = true;
            }
            
            toggleGoogleTilesBtn.textContent = 'Hide Realistic 3D Tiles';
            toggleGoogleTilesBtn.classList.add('active');
            console.log('Google 3D Tiles enabled');
            
          } catch (error) {
            console.error('Failed to load Google 3D Tiles:', error);
            googleTilesEnabled = false;
            
            // Try alternative method if the first one fails
            try {
              console.log('Trying alternative Google 3D Tiles method...');
              if (!googleTileset) {
                // Alternative: Use Google Earth Enterprise imagery
                viewer.imageryLayers.addImageryProvider(
                  await Cesium.GoogleEarthEnterpriseImageryProvider.fromUrl('https://earth.google.com')
                );
              }
              
              toggleGoogleTilesBtn.textContent = 'Hide Realistic 3D Tiles';
              toggleGoogleTilesBtn.classList.add('active');
              console.log('Google imagery layer enabled');
              googleTilesEnabled = true;
              
            } catch (secondError) {
              console.error('Both Google 3D Tiles methods failed:', secondError);
              alert('Google 3D Tiles not available. This feature may require a newer version of Cesium or different configuration.');
            }
          }
        } else {
          // Disable Google 3D Tiles
          if (googleTileset) {
            googleTileset.show = false;
          }
          
          toggleGoogleTilesBtn.textContent = 'Show Realistic 3D Tiles';
          toggleGoogleTilesBtn.classList.remove('active');
          console.log('Google 3D Tiles disabled');
        }
      });

      // Hole selector buttons
      const holeSelector = document.getElementById("holeSelector");
      const holeButtons = [];
      
      for (let i = 1; i <= 18; i++) {
        const btn = document.createElement("button");
        btn.textContent = `${i}`;
        btn.onclick = async () => {
          const path = courseFeatures.holeMap.get(String(i));
          if (!path || path.length < 2) return;

          // currentPath = path; // Remove this line since we use currentHolePath
          currentHoleId = i;
          currentHolePath = path;
          currentGreenPoly = courseFeatures.greenMap.get(String(i));

          // Clear course feature cache when hole changes (PERFORMANCE OPTIMIZATION)
          courseFeatureCache = null;
          currentCachedHoleId = null;

          // Clear existing slope visualization
          slopeArrowDS.entities.removeAll();
          slopeDots.removeAll();
          
          // Set default positions for this hole
          await setDefaultPositionsForHole(i);

          const orientation = getCorrectHoleOrientation(i, path);
          const tee = orientation.tee;
          const green = orientation.green;

          // Calculate camera position and orientation
          const sCarto = Cesium.Cartographic.fromCartesian(tee);
          const gCarto = Cesium.Cartographic.fromCartesian(green);
          
          // Use original bearing calculation that worked
          const dLon = gCarto.longitude - sCarto.longitude;
          const bearing = Math.atan2(
            Math.sin(dLon) * Math.cos(gCarto.latitude),
            Math.cos(sCarto.latitude) * Math.sin(gCarto.latitude) -
            Math.sin(sCarto.latitude) * Math.cos(gCarto.latitude) * Math.cos(dLon)
          );
          const heading = Cesium.Math.zeroToTwoPi(bearing);
          
          // But still log both for comparison
          const teeLon = Cesium.Math.toDegrees(sCarto.longitude);
          const teeLat = Cesium.Math.toDegrees(sCarto.latitude);
          const greenLon = Cesium.Math.toDegrees(gCarto.longitude);
          const greenLat = Cesium.Math.toDegrees(gCarto.latitude);
          const headingDeg = computeHeadingDeg(teeLon, teeLat, greenLon, greenLat);
          console.log(`Original bearing: ${Cesium.Math.toDegrees(bearing).toFixed(1)}°, New heading: ${headingDeg.toFixed(1)}°`);
          const holeLen = Cesium.Cartesian3.distance(tee, green);

          // Sample terrain for camera height
          const start = Cesium.Cartographic.fromCartesian(path[0]);
          const [sample] = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [new Cesium.Cartographic(start.longitude, start.latitude, 0)]
          );
          const terrainHeight = sample.height || 0;
          const hole_height = Math.max((holeLen ** 0.83) * 0.7 + terrainHeight, 300);

          // Calculate camera offset
          const hole_offset = (holeLen ** 0.87) * 0.7 + 50;
          const R = 6378137.0;
          const dLat = (hole_offset * Math.cos(bearing + Math.PI)) / R;
          const dLon2 = (hole_offset * Math.sin(bearing + Math.PI)) / (R * Math.cos(sCarto.latitude));
          const destLat = sCarto.latitude + dLat;
          const destLon = sCarto.longitude + dLon2;

          // Fly to hole
          viewer.camera.flyTo({
            destination: Cesium.Cartesian3.fromRadians(destLon, destLat, hole_height),
            orientation: {
              heading,
              pitch: Cesium.Math.toRadians(-30 + (holeLen**0.38)),
              roll: 0
            },
            duration: 0.5
          });
        };
        
        holeButtons.push(btn);
        holeSelector.appendChild(btn);
      }

      // Note: Tee/Fairway/Green buttons are now always-visible above

      // Wire up the always-visible navigation buttons
      const prevHoleBtn = document.getElementById('prevHoleBtn');
      const nextHoleBtn = document.getElementById('nextHoleBtn');
      const fullCourseBtn = document.getElementById('fullCourseBtn');
      
      // Wire up the always-visible view buttons
      const teeViewBtn = document.getElementById('teeViewBtn');
      const fairwayViewBtn = document.getElementById('fairwayViewBtn');
      const greenViewBtn = document.getElementById('greenViewBtn');
      
      teeViewBtn.onclick = async () => {
        if (!currentHolePath || currentHolePath.length < 2 || !currentHoleId) return;
        holeButtons[currentHoleId - 1].click();
      };
      
      fairwayViewBtn.onclick = async () => {
        if (!currentHolePath || currentHolePath.length < 2) return;
        
        const path = currentHolePath;
        const orientation = getCorrectHoleOrientation(currentHoleId, path);
        const tee = orientation.tee;
        const green = orientation.green;
        
        // Place green center marker with terrain sampling
        if (currentGreenPoly) {
          const greenCenter = getPolygonCenter(currentGreenPoly);
          const greenCenterCarto = Cesium.Cartographic.fromCartesian(greenCenter);
          const greenCenterLon = Cesium.Math.toDegrees(greenCenterCarto.longitude);
          const greenCenterLat = Cesium.Math.toDegrees(greenCenterCarto.latitude);
          
          // Sample terrain for green center
          try {
            const [greenSample] = await Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              [new Cesium.Cartographic(Cesium.Math.toRadians(greenCenterLon), Cesium.Math.toRadians(greenCenterLat), 0)]
            );
            await placeGreenCenterMarker(greenCenterLon, greenCenterLat, greenSample.height || 0);
          } catch (error) {
            console.warn('Terrain sampling failed for green center:', error);
            await placeGreenCenterMarker(greenCenterLon, greenCenterLat, 0);
          }
        }
        
        if (currentGreenPoly) {
          console.log('Building slope for fairway view...');
          await buildSlopeForGreen(currentGreenPoly);
        }
        
        const midIndex = Math.floor(path.length / 2);
        const midPoint = path[midIndex];
        const midCarto = Cesium.Cartographic.fromCartesian(midPoint);
        const gCarto = Cesium.Cartographic.fromCartesian(green);
        
        // Use consistent heading calculation
        const midLon = Cesium.Math.toDegrees(midCarto.longitude);
        const midLat = Cesium.Math.toDegrees(midCarto.latitude);
        const greenLon = Cesium.Math.toDegrees(gCarto.longitude);
        const greenLat = Cesium.Math.toDegrees(gCarto.latitude);
        
        const headingDeg = computeHeadingDeg(midLon, midLat, greenLon, greenLat);
        const headingRad = Cesium.Math.toRadians(headingDeg);
        const heading = Cesium.Math.zeroToTwoPi(headingRad);
        const holeLen = Cesium.Cartesian3.distance(tee, green);
        
        let terrainHeight = 0;
        try {
          const [sample] = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [new Cesium.Cartographic(midCarto.longitude, midCarto.latitude, 0)]
          );
          terrainHeight = sample.height || 0;
        } catch(e) {
          console.warn('terrain sample failed', e);
        }
        
        const fairway_height = Math.max((holeLen ** 0.75) * 0.8 + terrainHeight, 200);
        const fairway_offset = Math.max((holeLen ** 0.85) * 0.6 + 30, 80);
        const backwardHeadingRad = headingRad + Math.PI;
        const R = 6378137.0;
        const dLat = (fairway_offset * Math.cos(backwardHeadingRad)) / R;
        const dLon2 = (fairway_offset * Math.sin(backwardHeadingRad)) / (R * Math.cos(midCarto.latitude));
        const destLat = midCarto.latitude + dLat;
        const destLon = midCarto.longitude + dLon2;
        
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromRadians(destLon, destLat, fairway_height),
          orientation: {
            heading,
            pitch: Cesium.Math.toRadians(-25 + (holeLen**0.35)),
            roll: 0
          },
          duration: 0.4
        });
      };
      
      greenViewBtn.onclick = async () => {
        if (!currentHolePath) return;
        const path = currentHolePath;
        const orientation = getCorrectHoleOrientation(currentHoleId, path);
        const tee = orientation.tee;
        const green = orientation.green;
        
        // Place green center marker with terrain sampling
        if (currentGreenPoly) {
          const greenCenter = getPolygonCenter(currentGreenPoly);
          const greenCenterCarto = Cesium.Cartographic.fromCartesian(greenCenter);
          const greenCenterLon = Cesium.Math.toDegrees(greenCenterCarto.longitude);
          const greenCenterLat = Cesium.Math.toDegrees(greenCenterCarto.latitude);
          
          // Sample terrain for green center
          try {
            const [greenSample] = await Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              [new Cesium.Cartographic(Cesium.Math.toRadians(greenCenterLon), Cesium.Math.toRadians(greenCenterLat), 0)]
            );
            await placeGreenCenterMarker(greenCenterLon, greenCenterLat, greenSample.height || 0);
          } catch (error) {
            console.warn('Terrain sampling failed for green center:', error);
            await placeGreenCenterMarker(greenCenterLon, greenCenterLat, 0);
          }
        }
        
        if (currentGreenPoly) {
          console.log('Building slope for current green...');
          await buildSlopeForGreen(currentGreenPoly);
        }

        const gCarto = Cesium.Cartographic.fromCartesian(green);
        const tCarto = Cesium.Cartographic.fromCartesian(tee);
        const dLon = tCarto.longitude - gCarto.longitude;
        let bearing = Math.atan2(
          Math.sin(dLon) * Math.cos(tCarto.latitude),
          Math.cos(gCarto.latitude) * Math.sin(tCarto.latitude) -
          Math.sin(gCarto.latitude) * Math.cos(tCarto.latitude) * Math.cos(dLon)
        );
        bearing += Math.PI;

        let terrainHeight = 0;
        try {
          const [sample] = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [new Cesium.Cartographic(gCarto.longitude, gCarto.latitude, 0)]
          );
          terrainHeight = sample.height || 0;
        } catch(e) {
          console.warn('terrain sample failed', e);
        }
        const green_height = Math.max(terrainHeight + 125, 100);
        const R = 6378137.0;
        const green_offset = 0;
        const dLat2 = (green_offset * Math.cos(bearing)) / R;
        const dLon2 = (green_offset * Math.sin(bearing)) / (R * Math.cos(gCarto.latitude));
        const destLat = gCarto.latitude + dLat2;
        const destLon = gCarto.longitude + dLon2;
        const greenDest = Cesium.Cartesian3.fromRadians(destLon, destLat, green_height);
        const heading = Cesium.Math.zeroToTwoPi(bearing);

        viewer.camera.flyTo({ 
          destination: greenDest,
          orientation: { heading, pitch: Cesium.Math.toRadians(-90), roll:0 },
          duration: 0.3
        });
      };
      
      prevHoleBtn.onclick = () => {
        if (!currentHoleId) {
          holeButtons[17].click();
          return;
        }
        
        let prevHoleNum = currentHoleId - 1;
        if (prevHoleNum < 1) prevHoleNum = 18;
        
        let attempts = 0;
        while (attempts < 18) {
          const path = courseFeatures.holeMap.get(String(prevHoleNum));
          if (path && path.length >= 2) {
            holeButtons[prevHoleNum - 1].click();
            break;
          }
          prevHoleNum--;
          if (prevHoleNum < 1) prevHoleNum = 18;
          attempts++;
        }
      };

      nextHoleBtn.onclick = () => {
        if (!currentHoleId) {
          holeButtons[0].click();
          return;
        }
        
        let nextHoleNum = currentHoleId + 1;
        if (nextHoleNum > 18) nextHoleNum = 1;
        
        let attempts = 0;
        while (attempts < 18) {
          const path = courseFeatures.holeMap.get(String(nextHoleNum));
          if (path && path.length >= 2) {
            holeButtons[nextHoleNum - 1].click();
            break;
          }
          nextHoleNum++;
          if (nextHoleNum > 18) nextHoleNum = 1;
          attempts++;
        }
      };

      fullCourseBtn.onclick = () => {
        if (courseDataManager.courseBounds) {
          viewer.camera.flyTo({ destination: courseDataManager.courseBounds, duration: 0.5 });
        }
      };

      // ========== DISPERSION OVAL FUNCTIONALITY ==========
      
      // Global variables for oval dimensions
      let ovalWidth = 25; // Default width in meters
      let ovalDepth = 15; // Default depth in meters
      
      // Global variables for roll functionality
      let rollCondition = 'no'; // Selected roll condition
      let rollOvalEntity = null; // Roll oval visual entity
      
      // Shot type selection
      let currentShotType = 'approach'; // 'approach' or 'tee'
      let currentHoleLength = 0; // in yards
      
      // DOM refs
      const selectBtn = document.getElementById('selectBtn');
      const pinBtn = document.getElementById('pinBtn');
      const launchBtn = document.getElementById('launchBtn');
      const camBtn = document.getElementById('camBtn');
      const shotPovBtn = document.getElementById('shotPovBtn');
      const shotTypeSelection = document.getElementById('shotTypeSelection');
      const approachShotBtn = document.getElementById('approachShotBtn');
      const teeShotBtn = document.getElementById('teeShotBtn');
      const skillSel = document.getElementById('skillSelect');
      const rollSel = document.getElementById('rollSelect');
      const sampleChk = document.getElementById('toggleSamples');
      const unitsChk = document.getElementById('toggleUnits');
      const clearBtn = document.getElementById('clearBtn');
      const jackOfflineEl = document.getElementById('jackOffline');
      const jackDistPctEl = document.getElementById('jackDistPct');
      const jackParams = document.getElementById('jackParams');
      const jackParamsPct = document.getElementById('jackParamsPct');

      // State
      let selectingOval = false;
      let selectingPin = false;
      let selectingLaunch = false;
      let centerLon = 0;
      let centerLat = 0;
      let ovalEntity = null;
      let centerPointEntity = null;
      let pinEntity = null;
      let launchEntity = null;
      let sampleEntities = [];
      
      // Position tracking for sample regeneration optimization
      let lastSamplePosition = { lon: 0, lat: 0, width: 0, depth: 0 };
      const POSITION_THRESHOLD_METERS = 5; // Only regenerate if moved more than 5 meters
      
      // Debug flag for conditional logging
      const DEBUG_MODE = window.location.hostname === 'localhost' || window.location.search.includes('debug=true');

      const SKILL = {
        pro: { offlineDeg: 5.3, distPct: 0.037 },
        elite: { offlineDeg: 5.9, distPct: 0.044 },
        scratch: { offlineDeg: 6.4, distPct: 0.049 },
        good: { offlineDeg: 6.9, distPct: 0.055 },
        average: { offlineDeg: 7.7, distPct: 0.061 },
        bad: { offlineDeg: 11.2, distPct: 0.072 },
        terrible: { offlineDeg: 14, distPct: 0.084 }
      };

      // Coordination between manual edits and skill auto-sizing
      let sizingFromSkill = false;

      // Utils
      const metersPerDegLat = 110574.2727;
      const metersPerDegLonAt = lat => 111319.490793 * Math.cos(lat * Math.PI / 180);
      
      // Distance formatting function
      function formatDistance(meters) {
        const useYards = unitsChk.checked;
        if (useYards) {
          const yards = meters * 1.09361;
          if (yards < 10) {
            const feet = yards * 3;
            return feet.toFixed(0) + 'ft';
          }
          return yards.toFixed(0) + 'y';
        } else {
          return meters.toFixed(1) + 'm';
        }
      }
      
      // Clear all function
      function clearAll() {
        // Clear oval and center point
        if (ovalEntity) {
          viewer.entities.remove(ovalEntity);
          ovalEntity = null;
        }
        if (centerPointEntity) {
          viewer.entities.remove(centerPointEntity);
          centerPointEntity = null;
        }
        
        // Clear pin
        if (pinEntity) {
          viewer.entities.remove(pinEntity);
          pinEntity = null;
        }
        
        // Clear launch/tee position
        if (launchEntity) {
          viewer.entities.remove(launchEntity);
          launchEntity = null;
        }
        
        // Clear green center marker
        if (window.greenCenterMarker) {
          viewer.entities.remove(window.greenCenterMarker);
          window.greenCenterMarker = null;
        }
        
        // Clear samples
        clearSamples();
        
        // Reset center coordinates
        centerLon = 0;
        centerLat = 0;
        
        // Reset distance displays
        document.getElementById('shotDistDisplay').textContent = '--';
        document.getElementById('intendedDistDisplay').textContent = '--';
        document.getElementById('avgDistDisplay').textContent = '--';
        
        // Deactivate selection buttons
        selectBtn.classList.remove('active');
        pinBtn.classList.remove('active');
        launchBtn.classList.remove('active');
        selectingOval = false;
        selectingPin = false;
        selectingLaunch = false;
      }

      // Ellipse positions
      function ellipseLonLatArray(lonDeg, latDeg, semiMajor, semiMinor, rotRad, segments = 128) {
        const arr = [];
        const cosR = Math.cos(rotRad), sinR = Math.sin(rotRad);
        const mPerLon = metersPerDegLonAt(latDeg);
        for (let i = 0; i <= segments; i++) {
          const th = 2 * Math.PI * i / segments;
          const x = semiMajor * Math.cos(th);
          const y = semiMinor * Math.sin(th);
          const xr = x * cosR - y * sinR;
          const yr = x * sinR + y * cosR;
          arr.push(lonDeg + xr / mPerLon, latDeg + yr / metersPerDegLat);
        }
        return arr;
      }

      function randomPointInEllipse(semiMajor, semiMinor) {
        const r = Math.sqrt(Math.random());
        const th = 2 * Math.PI * Math.random();
        return { x: r * semiMajor * Math.cos(th), y: r * semiMinor * Math.sin(th) };
      }
      
      // Helper function to check if a point is inside an ellipse
      function isPointInEllipse(lon, lat, centerLon, centerLat, semiMajor, semiMinor, rotRad) {
        const mPerLon = metersPerDegLonAt(centerLat);
        
        // Transform point to ellipse local coordinates
        const dx = (lon - centerLon) * mPerLon;
        const dy = (lat - centerLat) * metersPerDegLat;
        
        // Rotate to align with ellipse axes
        const cosR = Math.cos(-rotRad);
        const sinR = Math.sin(-rotRad);
        const x = dx * cosR - dy * sinR;
        const y = dx * sinR + dy * cosR;
        
        // Check if point is inside ellipse
        return (x * x) / (semiMajor * semiMajor) + (y * y) / (semiMinor * semiMinor) <= 1.0;
      }

      function getRollMultipliers(condition) {
        switch (condition) {
          case 'soft':
            return { widthMultiplier: 1.05, depthMultiplier: 1.4 };
          case 'medium':
            return { widthMultiplier: 1.1, depthMultiplier: 1.8 };
          case 'firm':
            return { widthMultiplier: 1.15, depthMultiplier: 2.2 };
          case 'very-firm':
            return { widthMultiplier: 1.2, depthMultiplier: 2.6 };
          default: // 'no'
            return { widthMultiplier: 1.0, depthMultiplier: 1.0 };
        }
      }

      function calculateMinDistanceToPath(polygon, path) {
        if (!polygon || !path || polygon.length === 0 || path.length === 0) return Infinity;
        
        let minDistance = Infinity;
        for (const polyPoint of polygon) {
          for (const pathPoint of path) {
            const distance = Cesium.Cartesian3.distance(polyPoint, pathPoint);
            minDistance = Math.min(minDistance, distance);
          }
        }
        return minDistance;
      }

      function createRollOval() {
        if (rollCondition === 'no') {
          if (rollOvalEntity) {
            viewer.entities.remove(rollOvalEntity);
            rollOvalEntity = null;
          }
          return null;
        }

        const { widthMultiplier, depthMultiplier } = getRollMultipliers(rollCondition);
        
        // Calculate roll oval dimensions
        const rollWidth = ovalWidth * widthMultiplier;
        const rollDepth = ovalDepth * depthMultiplier;
        
        // Calculate offset so roll oval's closest point coincides with dispersion oval's closest point
        // This creates proper overlapping ovals with shared closest edge toward tee
        const originalSemiDepth = ovalDepth / 2;  // Half-depth of original oval
        const rollSemiDepth = rollDepth / 2;      // Half-depth of roll oval
        
        // Offset = difference in semi-depths (positive = forward toward target)
        const offset = rollSemiDepth - originalSemiDepth;
        
        // Calculate heading from starting position to target (same as dispersion oval orientation)
        const baseHeading = getBaseHeadingDeg();
        console.log(`Base heading from starting position to target: ${baseHeading.toFixed(1)}°`);
        
        // Use the direct heading without transformation for offset calculation
        const headingRad = Cesium.Math.toRadians(baseHeading);
        const mPerLon = metersPerDegLonAt(centerLat);
        
        // Offset in direction of target (forward from dispersion oval center)
        // Using standard navigation coordinates: East=0°, North=90°
        const offsetX = offset * Math.sin(headingRad);
        const offsetY = offset * Math.cos(headingRad);
        
        console.log(`Roll offset: ${offset}m at heading ${baseHeading.toFixed(1)}° → dx=${offsetX.toFixed(2)}m, dy=${offsetY.toFixed(2)}m`);
        
        const rollCenterLon = centerLon + offsetX / mPerLon;
        const rollCenterLat = centerLat + offsetY / metersPerDegLat;
        
        console.log(`Roll positioning: original semi-depth=${originalSemiDepth}m, roll semi-depth=${rollSemiDepth}m, offset=${offset}m (overlap positioning)`);
        
        // Create roll oval geometry (use same rotation formula as dispersion oval)
        const rollSemiMajor = Math.max(rollWidth, rollDepth) / 2;
        const rollSemiMinor = Math.min(rollWidth, rollDepth) / 2;
        const rollRotDeg = ((360 - getBaseHeadingDeg()) + 0) % 360; // Same as dispersion oval
        const rollRotRad = Cesium.Math.toRadians(rollRotDeg);
        const rollLonLatArr = ellipseLonLatArray(rollCenterLon, rollCenterLat, rollSemiMajor, rollSemiMinor, rollRotRad);
        
        console.log(`Roll rotation: ${rollRotDeg.toFixed(1)}° (same as dispersion oval)`);
        
        // Remove existing roll oval
        if (rollOvalEntity) {
          viewer.entities.remove(rollOvalEntity);
        }
        
        // Create new roll oval entity (polyline like dispersion oval)
        rollOvalEntity = viewer.entities.add({
          polyline: {
            positions: Cesium.Cartesian3.fromDegreesArray(rollLonLatArr),
            width: 4,
            material: Cesium.Color.ORANGE,
            clampToGround: true,
            classificationType: Cesium.ClassificationType.TERRAIN
          }
        });
        
        console.log(`Roll oval created: center (${rollCenterLon.toFixed(6)}, ${rollCenterLat.toFixed(6)}), width: ${rollWidth}m, depth: ${rollDepth}m`);
        
        return {
          centerLon: rollCenterLon,
          centerLat: rollCenterLat,
          width: rollWidth,
          depth: rollDepth,
          semiMajor: rollSemiMajor,
          semiMinor: rollSemiMinor,
          rotation: rollRotRad
        };
      }

      function clearSamples() {
        // Return entities to pool instead of removing them
        sampleEntities.forEach(entity => {
          if (window.performanceManager) {
            window.performanceManager.returnEntityToPool('samplePoints', entity);
          } else {
            viewer.entities.remove(entity);
          }
        });
        sampleEntities.length = 0; // Clear array more efficiently
        
        // Also clear roll oval if it exists
        if (rollOvalEntity) {
          viewer.entities.remove(rollOvalEntity);
          rollOvalEntity = null;
        }
        
        // Reset position tracking to force regeneration next time
        lastSamplePosition = { lon: 0, lat: 0, width: 0, depth: 0 };
      }

      function updateSampleVisibility() {
        const show = sampleChk.checked;
        sampleEntities.forEach(e => e.show = show);
      }

      function performMemoryCleanup() {
        // Clear samples
        clearSamples();
        
        // Clear performance manager entity pools
        if (window.performanceManager) {
          window.performanceManager.clearEntityPool('samplePoints', viewer);
          
          // Clear any active debounce timers
          window.performanceManager.debounceTimers.clear();
        }
        
        // Clear course feature cache
        currentCachedHoleId = null;
        courseFeatureCache = null;
        
        // Force garbage collection hint
        if (window.gc) {
          try {
            window.gc();
          } catch (e) {
            // gc() may not be available in all environments
          }
        }
        
        if (DEBUG_MODE) console.log('Memory cleanup completed');
      }

      async function placePin(lon, lat, terrainHeight = null) {
        if (pinEntity) viewer.entities.remove(pinEntity);
        
        // Always use CLAMP_TO_GROUND - ignore terrainHeight parameter
        console.log(`Placing pin at (${lon.toFixed(4)}, ${lat.toFixed(4)}) with CLAMP_TO_GROUND`);
        
        // Create pin with ground clamping
        pinEntity = viewer.entities.add({
          position: Cesium.Cartesian3.fromDegrees(lon, lat),
          billboard: {
            image: 'data:image/svg+xml;base64,' + btoa(`
              <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 14 14">
                <polygon points="7,1 13,13 7,10 1,13" fill="yellow" stroke="black" stroke-width="1"/>
              </svg>
            `),
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            pixelOffset: new Cesium.Cartesian2(0, -7),
            disableDepthTestDistance: 1000
          }
        });
        
        // Force a scene render and update to ensure proper ground clamping
        viewer.scene.requestRender();
        
        // Small delay to ensure terrain is loaded and pin is properly clamped
        setTimeout(() => {
          if (pinEntity) {
            pinEntity.show = false;
            setTimeout(() => {
              if (pinEntity) pinEntity.show = true;
            }, 50);
          }
        }, 100);
      }
      
      async function placeGreenCenterMarker(lon, lat, terrainHeight = null) {
        // Remove existing marker if it exists
        if (window.greenCenterMarker) {
          viewer.entities.remove(window.greenCenterMarker);
        }
        
        // Use provided terrain height or sample if not provided
        let height = terrainHeight;
        if (height === null) {
          try {
            const [sample] = await Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              [new Cesium.Cartographic(Cesium.Math.toRadians(lon), Cesium.Math.toRadians(lat), 0)]
            );
            height = sample.height || 0;
          } catch (error) {
            console.warn('Terrain sampling failed for green center marker, using CLAMP_TO_GROUND:', error);
            height = 0;
          }
        }
        
        // Create marker with proper ground clamping
        if (height > 0) {
          // Add extra delay to ensure terrain is loaded
          await new Promise(resolve => setTimeout(resolve, 100));
          
          window.greenCenterMarker = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat, height + 0.5), // Add 0.5m above terrain
            point: {
              pixelSize: 5,
              color: Cesium.Color.BLACK,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 1,
              disableDepthTestDistance: 1000
            }
          });
        } else {
          // Fallback to CLAMP_TO_GROUND
          window.greenCenterMarker = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat),
            point: {
              pixelSize: 5,
              color: Cesium.Color.BLACK,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 1,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              disableDepthTestDistance: 1000
            }
          });
        }
        
        // Force a scene render to ensure proper positioning
        viewer.scene.requestRender();
      }
      
      async function setDefaultPositionsForHole(holeId) {
        const greenPoly = courseFeatures.greenMap.get(String(holeId));
        const holePath = courseFeatures.holeMap.get(String(holeId));
        const teePoly = courseFeatures.teeMap.get(String(holeId));
        
        if (!greenPoly || !holePath || holePath.length < 2) return;
        
        // Update shot type UI based on hole length (only if not already set by button)
        if (arguments.length < 2) { // Only update if not called from button with preserveMode = true
          updateShotTypeUI(holeId);
        }
        
        // Calculate key positions
        const greenCenter = getPolygonCenter(greenPoly);
        const greenCenterCarto = Cesium.Cartographic.fromCartesian(greenCenter);
        const greenCenterLon = Cesium.Math.toDegrees(greenCenterCarto.longitude);
        const greenCenterLat = Cesium.Math.toDegrees(greenCenterCarto.latitude);
        
        const orientation = getCorrectHoleOrientation(holeId, holePath);
        const midIndex = Math.floor(holePath.length / 2);
        const fairwayMidPoint = holePath[midIndex];
        const fairwayMidCarto = Cesium.Cartographic.fromCartesian(fairwayMidPoint);
        const fairwayMidLon = Cesium.Math.toDegrees(fairwayMidCarto.longitude);
        const fairwayMidLat = Cesium.Math.toDegrees(fairwayMidCarto.latitude);
        
        // Calculate tee center if available
        let teeCenterLon = fairwayMidLon; // Fallback to fairway midpoint
        let teeCenterLat = fairwayMidLat;
        if (teePoly && teePoly.length > 0) {
          const teeCenter = getPolygonCenter(teePoly);
          const teeCenterCarto = Cesium.Cartographic.fromCartesian(teeCenter);
          teeCenterLon = Cesium.Math.toDegrees(teeCenterCarto.longitude);
          teeCenterLat = Cesium.Math.toDegrees(teeCenterCarto.latitude);
        }
        
        try {
          // Sample terrain for all positions
          const positionsToSample = [
            new Cesium.Cartographic(Cesium.Math.toRadians(greenCenterLon), Cesium.Math.toRadians(greenCenterLat), 0),
            new Cesium.Cartographic(Cesium.Math.toRadians(fairwayMidLon), Cesium.Math.toRadians(fairwayMidLat), 0),
            new Cesium.Cartographic(Cesium.Math.toRadians(teeCenterLon), Cesium.Math.toRadians(teeCenterLat), 0)
          ];
          
          const [greenSample, fairwaySample, teeSample] = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            positionsToSample
          );
          
          // Always place pin at green center initially (per user requirement)
          console.log(`INITIAL SETUP: Placing pin at green center (${greenCenterLon.toFixed(4)}, ${greenCenterLat.toFixed(4)})`);
          await placePin(greenCenterLon, greenCenterLat);
          
          // Set oval aim point based on current shot type
          if (currentShotType === 'tee' && currentHoleLength >= 300) {
            // Tee shot on long hole: aim at fairway midpoint
            centerLon = fairwayMidLon;
            centerLat = fairwayMidLat;
            console.log(`INITIAL SETUP: Oval aiming at fairway midpoint (${fairwayMidLon.toFixed(4)}, ${fairwayMidLat.toFixed(4)})`);
          } else {
            // Short holes or approach shots: aim at green center
            centerLon = greenCenterLon;
            centerLat = greenCenterLat;
            console.log(`INITIAL SETUP: Oval aiming at green center (${greenCenterLon.toFixed(4)}, ${greenCenterLat.toFixed(4)})`);
          }
          
          // Place tee position at tee box initially (default for tee shot)
          console.log(`INITIAL SETUP: Placing tee at tee box (${teeCenterLon.toFixed(4)}, ${teeCenterLat.toFixed(4)}) with CLAMP_TO_GROUND`);
          if (launchEntity) viewer.entities.remove(launchEntity);
          launchEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(teeCenterLon, teeCenterLat),
            point: { pixelSize: 5, color: Cesium.Color.CYAN, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, disableDepthTestDistance: 1000 }
          });
          
        } catch (error) {
          console.warn('Terrain sampling failed, using CLAMP_TO_GROUND fallback:', error);
          
          // Fallback without terrain sampling - always place pin at green center initially
          console.log(`FALLBACK SETUP: Placing pin at green center (${greenCenterLon.toFixed(4)}, ${greenCenterLat.toFixed(4)})`);
          await placePin(greenCenterLon, greenCenterLat, 0);
          
          // Set oval aim point based on current shot type
          if (currentShotType === 'tee' && currentHoleLength >= 300) {
            // Tee shot on long hole: aim at fairway midpoint
            centerLon = fairwayMidLon;
            centerLat = fairwayMidLat;
            console.log(`FALLBACK SETUP: Oval aiming at fairway midpoint (${fairwayMidLon.toFixed(4)}, ${fairwayMidLat.toFixed(4)})`);
          } else {
            // Short holes or approach shots: aim at green center
            centerLon = greenCenterLon;
            centerLat = greenCenterLat;
            console.log(`FALLBACK SETUP: Oval aiming at green center (${greenCenterLon.toFixed(4)}, ${greenCenterLat.toFixed(4)})`);
          }
          
          // Place tee position at tee box initially
          console.log(`FALLBACK SETUP: Placing tee at tee box (${teeCenterLon.toFixed(4)}, ${teeCenterLat.toFixed(4)})`);
          if (launchEntity) viewer.entities.remove(launchEntity);
          launchEntity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(teeCenterLon, teeCenterLat),
            point: { pixelSize: 5, color: Cesium.Color.CYAN, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, disableDepthTestDistance: 1000 }
          });
        }
        
        // Rebuild oval and generate points with new defaults
        rebuildOval();
        autoSizeFromSkill();
        generateRandomPoints();
        updateDistanceDisplays();
        
        console.log(`Set default positions for hole ${holeId}: Green center (${greenCenterLon.toFixed(4)}, ${greenCenterLat.toFixed(4)}), Fairway mid (${fairwayMidLon.toFixed(4)}, ${fairwayMidLat.toFixed(4)})`);
      }

      function rebuildOval() {
        if (centerLon === 0 && centerLat === 0) return; // No center set yet
        
        // Use global variables for dispersion oval dimensions
        const w = ovalWidth;
        const d = ovalDepth;
        const userRot = 0; // Default rotation
        const rotDeg = ((360 - getBaseHeadingDeg()) + userRot) % 360;
        const semiMajor = Math.max(w, d) / 2;
        const semiMinor = Math.min(w, d) / 2;
        const rotRad = Cesium.Math.toRadians(rotDeg);

        if (ovalEntity) viewer.entities.remove(ovalEntity);
        if (centerPointEntity) viewer.entities.remove(centerPointEntity);

        const lonLatArr = ellipseLonLatArray(centerLon, centerLat, semiMajor, semiMinor, rotRad);
        
        // Create oval with proper ground clamping
        ovalEntity = viewer.entities.add({
          polyline: {
            positions: Cesium.Cartesian3.fromDegreesArray(lonLatArr),
            width: 4,
            material: Cesium.Color.RED,
            clampToGround: true,
            classificationType: Cesium.ClassificationType.TERRAIN // Ensure it clamps to terrain, not 3D tiles
          }
        });

        // center marker with consistent clamping
        centerPointEntity = viewer.entities.add({
          position: Cesium.Cartesian3.fromDegrees(centerLon, centerLat),
          point: { 
            pixelSize: 5, 
            color: Cesium.Color.RED, 
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
            disableDepthTestDistance: 1000
          }
        });
        
        // Create roll oval if roll conditions are enabled
        createRollOval();
        
        // Generate sample points for the new oval
        generateRandomPoints();
        
        // Force a scene render to ensure clamping is applied
        viewer.scene.requestRender();
      }

      // Expected Strokes Calculation Functions
      function calculateExpectedStrokes(distanceYards, courseFeature) {
        const x = distanceYards;
        let strokes;
        
        // Don't calculate for distances less than 0 or greater than 600 yards
        if (x < 0 || x > 600) {
          return null;
        }
        
        switch (courseFeature) {
          case 'fairway':
          case 'tee': // Tee expected strokes same as fairway
            if (x < 7.43) {
              // Linear extrapolation from (0, 1) to first point (7.43, polynomial_value)
              const firstY = 1.87505684 + 3.44179367e-02 * 7.43 + -5.63306650e-04 * Math.pow(7.43, 2) + 4.70425536e-06 * Math.pow(7.43, 3) + -2.02041273e-08 * Math.pow(7.43, 4) + 4.38015739e-11 * Math.pow(7.43, 5) + -3.78163505e-14 * Math.pow(7.43, 6);
              const slope = (firstY - 1.0) / (7.43 - 0);
              strokes = 1.0 + slope * x;
            } else if (x <= 348.9) {
              // Degree 6 polynomial (fitted coefficients)
              strokes = 1.87505684 + 3.44179367e-02 * x + -5.63306650e-04 * Math.pow(x, 2) + 4.70425536e-06 * Math.pow(x, 3) + -2.02041273e-08 * Math.pow(x, 4) + 4.38015739e-11 * Math.pow(x, 5) + -3.78163505e-14 * Math.pow(x, 6);
            } else {
              // Linear extrapolation from last point to (600, 5.25)
              const lastY = 1.87505684 + 3.44179367e-02 * 348.9 + -5.63306650e-04 * Math.pow(348.9, 2) + 4.70425536e-06 * Math.pow(348.9, 3) + -2.02041273e-08 * Math.pow(348.9, 4) + 4.38015739e-11 * Math.pow(348.9, 5) + -3.78163505e-14 * Math.pow(348.9, 6);
              const slope = (5.25 - lastY) / (600 - 348.9);
              strokes = lastY + slope * (x - 348.9);
            }
            break;
            
          case 'rough':
            if (x < 7.76) {
              // Linear extrapolation from (0, 1.5) to first point
              const firstY = 2.01325284 + 3.73834464e-02 * 7.76 + -6.08542541e-04 * Math.pow(7.76, 2) + 5.01193038e-06 * Math.pow(7.76, 3) + -2.08847962e-08 * Math.pow(7.76, 4) + 4.32228049e-11 * Math.pow(7.76, 5) + -3.53899274e-14 * Math.pow(7.76, 6);
              const slope = (firstY - 1.5) / (7.76 - 0);
              strokes = 1.5 + slope * x;
            } else if (x <= 348.9) {
              // Degree 6 polynomial (fitted coefficients)
              strokes = 2.01325284 + 3.73834464e-02 * x + -6.08542541e-04 * Math.pow(x, 2) + 5.01193038e-06 * Math.pow(x, 3) + -2.08847962e-08 * Math.pow(x, 4) + 4.32228049e-11 * Math.pow(x, 5) + -3.53899274e-14 * Math.pow(x, 6);
            } else {
              // Linear extrapolation from last point to (600, 5.4)
              const lastY = 2.01325284 + 3.73834464e-02 * 348.9 + -6.08542541e-04 * Math.pow(348.9, 2) + 5.01193038e-06 * Math.pow(348.9, 3) + -2.08847962e-08 * Math.pow(348.9, 4) + 4.32228049e-11 * Math.pow(348.9, 5) + -3.53899274e-14 * Math.pow(348.9, 6);
              const slope = (5.4 - lastY) / (600 - 348.9);
              strokes = lastY + slope * (x - 348.9);
            }
            break;
            
          case 'sand':
            if (x < 7.96) {
              // Linear extrapolation from (0, 2) to first point
              const firstY = 2.14601649 + 2.61044155e-02 * 7.96 + -2.69537153e-04 * Math.pow(7.96, 2) + 1.48010114e-06 * Math.pow(7.96, 3) + -3.99813977e-09 * Math.pow(7.96, 4) + 5.24740763e-12 * Math.pow(7.96, 5) + -2.67577455e-15 * Math.pow(7.96, 6);
              const slope = (firstY - 2.0) / (7.96 - 0);
              strokes = 2.0 + slope * x;
            } else {
              // Degree 6 polynomial (fitted coefficients, valid 0-600)
              strokes = 2.14601649 + 2.61044155e-02 * x + -2.69537153e-04 * Math.pow(x, 2) + 1.48010114e-06 * Math.pow(x, 3) + -3.99813977e-09 * Math.pow(x, 4) + 5.24740763e-12 * Math.pow(x, 5) + -2.67577455e-15 * Math.pow(x, 6);
            }
            break;
            
          case 'recovery':
            if (x < 100) {
              // Linear extrapolation from (0, 3) to first point
              const firstY = 1.34932958 + 6.39685426e-02 * 100 + -6.38754410e-04 * Math.pow(100, 2) + 3.09148159e-06 * Math.pow(100, 3) + -7.60396073e-09 * Math.pow(100, 4) + 9.28546297e-12 * Math.pow(100, 5) + -4.46945896e-15 * Math.pow(100, 6);
              const slope = (firstY - 3.0) / (100 - 0);
              strokes = 3.0 + slope * x;
            } else {
              // Degree 6 polynomial (fitted coefficients, valid 100-600)
              strokes = 1.34932958 + 6.39685426e-02 * x + -6.38754410e-04 * Math.pow(x, 2) + 3.09148159e-06 * Math.pow(x, 3) + -7.60396073e-09 * Math.pow(x, 4) + 9.28546297e-12 * Math.pow(x, 5) + -4.46945896e-15 * Math.pow(x, 6);
            }
            break;
            
          case 'water':
            // Water hazard - penalty stroke + rough formula
            let roughStrokes;
            if (x < 7.76) {
              const firstY = 2.01325284 + 3.73834464e-02 * 7.76 + -6.08542541e-04 * Math.pow(7.76, 2) + 5.01193038e-06 * Math.pow(7.76, 3) + -2.08847962e-08 * Math.pow(7.76, 4) + 4.32228049e-11 * Math.pow(7.76, 5) + -3.53899274e-14 * Math.pow(7.76, 6);
              const slope = (firstY - 1.5) / (7.76 - 0);
              roughStrokes = 1.5 + slope * x;
            } else if (x <= 348.9) {
              roughStrokes = 2.01325284 + 3.73834464e-02 * x + -6.08542541e-04 * Math.pow(x, 2) + 5.01193038e-06 * Math.pow(x, 3) + -2.08847962e-08 * Math.pow(x, 4) + 4.32228049e-11 * Math.pow(x, 5) + -3.53899274e-14 * Math.pow(x, 6);
            } else {
              const lastY = 2.01325284 + 3.73834464e-02 * 348.9 + -6.08542541e-04 * Math.pow(348.9, 2) + 5.01193038e-06 * Math.pow(348.9, 3) + -2.08847962e-08 * Math.pow(348.9, 4) + 4.32228049e-11 * Math.pow(348.9, 5) + -3.53899274e-14 * Math.pow(348.9, 6);
              const slope = (5.4 - lastY) / (600 - 348.9);
              roughStrokes = lastY + slope * (x - 348.9);
            }
            strokes = roughStrokes + 1.0; // Add penalty stroke
            break;
            
          case 'green':
            if (x < 0.333) {
              strokes = 1.001;
            } else if (x <= 33.39) {
              // Degree 6 polynomial for putting (0.33-33.39 yards)
              strokes = 8.22701978e-01 + 3.48808959e-01 * x + -4.45111801e-02 * Math.pow(x, 2) + 3.05771434e-03 * Math.pow(x, 3) + -1.12243654e-04 * Math.pow(x, 4) + 2.09685358e-06 * Math.pow(x, 5) + -1.57305673e-08 * Math.pow(x, 6);
            } else {
              // For green distances > 33.39 yards, treat as fairway
              return calculateExpectedStrokes(x, 'fairway');
            }
            break;
            
          default:
            // Default to rough if feature unknown
            return calculateExpectedStrokes(x, 'rough');
        }
        
        // Enforce minimum of 1.001 strokes (never allow values under 1)
        return Math.max(1.001, strokes);
      }
      
      // PERFORMANCE OPTIMIZATION: Spatial Index Cache for Course Features
      let courseFeatureCache = null;
      let currentCachedHoleId = null;
      
      function buildCourseFeatureCache(holeId) {
        if (currentCachedHoleId === holeId && courseFeatureCache) {
          return courseFeatureCache; // Use existing cache
        }
        
        console.log(`Building spatial cache for hole ${holeId}...`);
        
        // Try both global and local courseDataManager
        const dataManager = window.courseDataManager || courseDataManager;
        console.log('dataManager exists:', !!dataManager);
        
        const cache = {
          waterPolygons: [],
          bunkerPolygons: [],
          teePolygons: [],
          fairwayPolygons: [],
          greenPolygon: null,
          holeId: holeId
        };
        
        // Pre-convert water hazards to degree coordinates (avoid repeated conversion)
        if (courseFeatures && courseFeatures.waterMap && holeId) {
          const waterHazards = courseFeatures.waterMap.get(String(holeId));
          if (waterHazards) {
            for (const water of waterHazards) {
              const degreeCoords = water.map(p => cartToDeg(p).slice(0, 2));
              cache.waterPolygons.push(degreeCoords);
            }
          }
        }
        
        // Pre-convert bunkers to degree coordinates
        if (courseFeatures && courseFeatures.bunkerMap && holeId) {
          const bunkers = courseFeatures.bunkerMap.get(String(holeId));
          if (bunkers) {
            for (const bunker of bunkers) {
              const degreeCoords = bunker.map(p => cartToDeg(p).slice(0, 2));
              cache.bunkerPolygons.push(degreeCoords);
            }
          }
        }
        
        // Add ALL tee polygons to cache - shots can land on any tee on the course
        if (dataManager && dataManager.courseFeatures) {
          const allTees = dataManager.courseFeatures.tees;
          if (allTees) {
            console.log(`Loading ALL ${allTees.length} tees for detection (no distance filtering)...`);
            for (const tee of allTees) {
              const degreeCoords = tee.map(p => cartToDeg(p).slice(0, 2));
              cache.teePolygons.push(degreeCoords);
            }
            console.log(`Added ${cache.teePolygons.length} tee polygons to cache`);
          }
        }
        
        // Add ALL fairway polygons to cache - shots can land on any fairway on the course
        if (dataManager && dataManager.courseFeatures) {
          const allFairways = dataManager.courseFeatures.fairways;
          if (allFairways) {
            console.log(`Loading ALL ${allFairways.length} fairways for detection (no distance filtering)...`);
            for (const fairway of allFairways) {
              const degreeCoords = fairway.map(p => cartToDeg(p).slice(0, 2));
              cache.fairwayPolygons.push(degreeCoords);
            }
            console.log(`Added ${cache.fairwayPolygons.length} fairway polygons to cache`);
          }
        }
        
        // Add individual rough polygons to cache (NOT the blanket background)
        if (dataManager && dataManager.courseFeatures) {
          const allRoughs = dataManager.courseFeatures.roughs;
          if (allRoughs) {
            console.log(`Loading ${allRoughs.length} individual rough areas for detection...`);
            for (const rough of allRoughs) {
              const degreeCoords = rough.map(p => cartToDeg(p).slice(0, 2));
              if (!cache.roughPolygons) cache.roughPolygons = [];
              cache.roughPolygons.push(degreeCoords);
            }
            console.log(`Added ${cache.roughPolygons ? cache.roughPolygons.length : 0} rough polygons to cache`);
          }
        }
        
        // Convert green polygon to degree coordinates for consistent detection
        if (currentGreenPoly) {
          try {
            const degreeCoords = currentGreenPoly.map(p => cartToDeg(p).slice(0, 2));
            cache.greenPolygon = degreeCoords;
            console.log(`Added green polygon with ${degreeCoords.length} points to cache`);
          } catch (error) {
            console.warn('Error converting green polygon:', error);
            cache.greenPolygon = null;
          }
        }
        
        courseFeatureCache = cache;
        currentCachedHoleId = holeId;
        console.log(`Spatial cache built: ${cache.waterPolygons.length} water, ${cache.bunkerPolygons.length} bunkers, ${cache.teePolygons.length} tees, ${cache.fairwayPolygons.length} fairways, ${cache.roughPolygons ? cache.roughPolygons.length : 0} roughs`);
        
        return cache;
      }
      
      function identifyCourseFeature(lon, lat) {
        try {
          // Build/get spatial cache for current hole
          const cache = buildCourseFeatureCache(currentHoleId);
          
          // Priority order: water, bunker, green, fairway, rough
          
          // Check water hazards first (using pre-converted coordinates)
          for (const waterPoly of cache.waterPolygons) {
            if (pointInPolyDeg(lon, lat, waterPoly)) {
              return 'water';
            }
          }
          
          // Check bunkers (using pre-converted coordinates)  
          for (const bunkerPoly of cache.bunkerPolygons) {
            if (pointInPolyDeg(lon, lat, bunkerPoly)) {
              return 'sand';
            }
          }
          
          // Check if point is in green - third priority (using consistent polygon detection)
          if (cache.greenPolygon) {
            if (pointInPolyDeg(lon, lat, cache.greenPolygon)) {
              console.log(`Point (${lon.toFixed(6)}, ${lat.toFixed(6)}) detected as GREEN`);
              return 'green';
            }
          }
          
          // Check tee polygons - fourth priority (using proper polygon detection)
          for (let i = 0; i < cache.teePolygons.length; i++) {
            const teePoly = cache.teePolygons[i];
            if (pointInPolyDeg(lon, lat, teePoly)) {
              console.log(`Point (${lon.toFixed(6)}, ${lat.toFixed(6)}) detected as TEE (polygon ${i})`);
              return 'tee';
            }
          }
          
          // Check fairway polygons - fifth priority (using proper polygon detection)
          for (let i = 0; i < cache.fairwayPolygons.length; i++) {
            const fairwayPoly = cache.fairwayPolygons[i];
            if (pointInPolyDeg(lon, lat, fairwayPoly)) {
              console.log(`Point (${lon.toFixed(6)}, ${lat.toFixed(6)}) detected as FAIRWAY (polygon ${i})`);
              return 'fairway';
            }
          }
          
          // Check individual rough polygons - sixth priority (only specific rough areas, not blanket)
          if (cache.roughPolygons) {
            for (let i = 0; i < cache.roughPolygons.length; i++) {
              const roughPoly = cache.roughPolygons[i];
              if (pointInPolyDeg(lon, lat, roughPoly)) {
                console.log(`Point (${lon.toFixed(6)}, ${lat.toFixed(6)}) detected as ROUGH (polygon ${i})`);
                return 'rough';
              }
            }
          }
          
          // If not in any specific area, default to rough
          console.log(`Point (${lon.toFixed(6)}, ${lat.toFixed(6)}) not in any specific area - defaulting to ROUGH`);
          return 'rough';
        } catch (error) {
          console.warn('Error identifying course feature:', error);
          return 'rough'; // Safe fallback
        }
      }
      
      function isPointInPolygon(point, polygon) {
        if (!polygon || polygon.length < 3) return false;
        
        const pointCarto = Cesium.Cartographic.fromCartesian(point);
        const pointLon = Cesium.Math.toDegrees(pointCarto.longitude);
        const pointLat = Cesium.Math.toDegrees(pointCarto.latitude);
        
        const polyDeg = polygon.map(p => {
          const carto = Cesium.Cartographic.fromCartesian(p);
          return [Cesium.Math.toDegrees(carto.longitude), Cesium.Math.toDegrees(carto.latitude)];
        });
        
        return pointInPolyDeg(pointLon, pointLat, polyDeg);
      }
      
      function isNearFairway(lon, lat, holePath) {
        if (!holePath || holePath.length < 2) return false;
        
        const point = Cesium.Cartesian3.fromDegrees(lon, lat);
        const fairwayWidth = 30; // meters - typical fairway width
        
        // Check distance to hole path
        let minDistance = Infinity;
        for (let i = 0; i < holePath.length - 1; i++) {
          const segmentStart = holePath[i];
          const segmentEnd = holePath[i + 1];
          const distance = distancePointToLineSegment(point, segmentStart, segmentEnd);
          minDistance = Math.min(minDistance, distance);
        }
        
        return minDistance <= fairwayWidth;
      }
      
      function distancePointToLineSegment(point, lineStart, lineEnd) {
        const A = Cesium.Cartesian3.subtract(point, lineStart, new Cesium.Cartesian3());
        const B = Cesium.Cartesian3.subtract(lineEnd, lineStart, new Cesium.Cartesian3());
        const B_length_sq = Cesium.Cartesian3.magnitudeSquared(B);
        
        if (B_length_sq === 0) {
          return Cesium.Cartesian3.distance(point, lineStart);
        }
        
        const t = Math.max(0, Math.min(1, Cesium.Cartesian3.dot(A, B) / B_length_sq));
        const projection = Cesium.Cartesian3.add(lineStart, Cesium.Cartesian3.multiplyByScalar(B, t, new Cesium.Cartesian3()), new Cesium.Cartesian3());
        
        return Cesium.Cartesian3.distance(point, projection);
      }

      function shouldRegenerateSamples(currentLon, currentLat, currentWidth, currentDepth) {
        // Always regenerate on first run
        if (lastSamplePosition.lon === 0 && lastSamplePosition.lat === 0) {
          lastSamplePosition = { lon: currentLon, lat: currentLat, width: currentWidth, depth: currentDepth };
          return true;
        }
        
        // Calculate distance moved in meters (rough approximation)
        const lonDiff = currentLon - lastSamplePosition.lon;
        const latDiff = currentLat - lastSamplePosition.lat;
        const distanceMeters = Math.sqrt(lonDiff * lonDiff + latDiff * latDiff) * 111000; // ~111km per degree
        
        // Check if oval dimensions changed significantly  
        const widthChanged = Math.abs(currentWidth - lastSamplePosition.width) > 5;
        const depthChanged = Math.abs(currentDepth - lastSamplePosition.depth) > 5;
        
        const shouldRegenerate = distanceMeters > POSITION_THRESHOLD_METERS || widthChanged || depthChanged;
        
        if (shouldRegenerate) {
          lastSamplePosition = { lon: currentLon, lat: currentLat, width: currentWidth, depth: currentDepth };
        }
        
        return shouldRegenerate;
      }

      async function generateRandomPoints() {
        if (!pinEntity) return;
        
        // Check if advanced short game is enabled for logging
        const advancedToggle = document.getElementById('advancedShortGame');
        const isAdvancedEnabled = advancedToggle && advancedToggle.checked;
        
        console.log('🔧 DEBUG: Advanced toggle found:', !!advancedToggle, 'Checked:', advancedToggle?.checked, 'Enabled:', isAdvancedEnabled);
        
        if (isAdvancedEnabled) {
          console.log('🏌️ STARTING ADVANCED SHORT GAME ANALYSIS...');
          console.log('📊 Will analyze: Ball Lie, Green Slope, Elevation Change, Green Percentage');
          console.log('⚡ Modifiers range from -0.2 to +0.35 strokes for shots ≤45 yards');
          console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
          // Reset debug counters
          window.debugShortGameCount = 0;
          window.debugKeyLookupCount = 0;
          window.debugColorCount = 0;
        } else {
          console.log('ℹ️ Advanced short game mode is disabled - no detailed logging');
        }
        
        // Check if we need to regenerate based on position change
        const currentWidth = ovalWidth;
        const currentDepth = ovalDepth;
        const positionChanged = shouldRegenerateSamples(centerLon, centerLat, currentWidth, currentDepth);
        
        if (!positionChanged && sampleEntities.length > 0) {
          return; // Skip regeneration if position hasn't changed significantly
        }
        
        // Show loading indicator
        const loadingIndicator = document.getElementById('sampleLoadingIndicator');
        if (loadingIndicator) loadingIndicator.style.display = 'block';
        
        clearSamples();
        let sumDist = 0;
        let sumExpectedStrokes = 0;
        let count = 0;
        
        // Condition counting for chart
        const conditionCounts = {
          water: 0,
          sand: 0, 
          green: 0,
          tee: 0,
          fairway: 0,
          rough: 0,
          recovery: 0,
          user_hazard: 0,
          user_ob: 0
        };
        
        console.log(`Generating ${rollCondition !== 'no' ? 'combined' : 'standard'} dispersion samples...`);

        // Use global variables for dispersion oval dimensions
        const w = ovalWidth;
        const d = ovalDepth;
        const semiMajor = Math.max(w, d) / 2;
        const semiMinor = Math.min(w, d) / 2;
        const userRotPts = 0; // Default rotation
        const rotDegPts = ((360 - getBaseHeadingDeg()) + userRotPts) % 360;
        const rotRad = Cesium.Math.toRadians(rotDegPts);
        const cosR = Math.cos(rotRad), sinR = Math.sin(rotRad);
        const mPerLon = metersPerDegLonAt(centerLat);

        const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
        const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
        const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
        const geod = new Cesium.EllipsoidGeodesic();

        // Get roll oval parameters if enabled
        const rollOvalParams = rollCondition !== 'no' ? createRollOval() : null;
        
        // Collect all sample points first for batch terrain sampling
        const samplePoints = [];
        
        if (rollOvalParams) {
          // Rejection sampling from combined dispersion + roll shape
          console.log('Sampling from combined dispersion + roll shape using rejection method');
          
          // Calculate bounding box that encompasses both ovals
          const dispersionRadius = Math.max(semiMajor, semiMinor);
          const rollRadius = Math.max(rollOvalParams.semiMajor, rollOvalParams.semiMinor);
          const maxRadius = Math.max(dispersionRadius, rollRadius);
          
          // Extend bounding box to account for roll oval offset
          const totalBoundingRadius = maxRadius + Math.abs(rollOvalParams.centerLon - centerLon) * mPerLon + Math.abs(rollOvalParams.centerLat - centerLat) * metersPerDegLat;
          
          let samplesGenerated = 0;
          while (samplePoints.length < 600 && samplesGenerated < 3000) { // Safety limit
            samplesGenerated++;
            
            // Generate random point in bounding box
            const angle = 2 * Math.PI * Math.random();
            const radius = totalBoundingRadius * Math.sqrt(Math.random());
            const dx = radius * Math.cos(angle);
            const dy = radius * Math.sin(angle);
            
            const lon = centerLon + dx / mPerLon;
            const lat = centerLat + dy / metersPerDegLat;
            
            // Check if point is inside either oval (dispersion OR roll)
            const inDispersion = isPointInEllipse(lon, lat, centerLon, centerLat, semiMajor, semiMinor, rotRad);
            const inRoll = isPointInEllipse(lon, lat, rollOvalParams.centerLon, rollOvalParams.centerLat, rollOvalParams.semiMajor, rollOvalParams.semiMinor, rollOvalParams.rotation);
            
            if (inDispersion || inRoll) {
              samplePoints.push({ lon, lat });
            }
          }
          console.log(`Generated ${samplePoints.length} samples from combined shape (${samplesGenerated} attempts)`);
        } else {
          // Standard sampling from dispersion oval only
          for (let i = 0; i < 600; i++) {
            const { x, y } = randomPointInEllipse(semiMajor, semiMinor);
            const xr = x * cosR - y * sinR;
            const yr = x * sinR + y * cosR;
            const lon = centerLon + xr / mPerLon;
            const lat = centerLat + yr / metersPerDegLat;
            samplePoints.push({ lon, lat });
          }
        }
        
        // Process sample points for display and calculations
        const processedPoints = [];
        for (let i = 0; i < samplePoints.length; i++) {
          const { lon, lat } = samplePoints[i];
          
          // Debug logging for first few points to see processing
          // Point processing logging removed

          geod.setEndPoints(Cesium.Cartographic.fromDegrees(pinLon, pinLat), Cesium.Cartographic.fromDegrees(lon, lat));
          const dist = geod.surfaceDistance;
          const distanceYards = dist * 1.09361; // Convert meters to yards
          
          // Debug distance for first few points
          // Distance logging removed
          
          // Identify course feature and calculate expected strokes with user-defined penalties
          let courseFeature;
          try {
            courseFeature = identifyCourseFeature(lon, lat);
          } catch (error) {
            console.warn('Error identifying course feature:', error);
            courseFeature = 'rough'; // Default fallback
          }
          
          let baseExpectedStrokes = calculateExpectedStrokesWithPenalties(distanceYards, lon, lat);
          let expectedStrokes = baseExpectedStrokes;
          
          // Determine final feature type early (needed for advanced short game check)
          let finalFeatureType = courseFeature;
          
          // Apply advanced short game modifiers if enabled, within range, and NOT on the green
          if (advancedToggle && advancedToggle.checked && distanceYards <= 45.0 && finalFeatureType !== 'green') {
            try {
              // Get globe for terrain sampling
              const globe = viewer.scene.globe;
              
              const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
              const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
              const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
              // Sample actual terrain height at pin position instead of using height=0
              const pinZ = sampleTerrainCached(globe, pinLon, pinLat);
              
              // Get green polygon for current hole
              const greenPoly = courseFeatures.greenMap.get(String(currentHoleId));
              
              expectedStrokes = calculateAdvancedExpectedStrokes(
                distanceYards, baseExpectedStrokes, lon, lat, 0, 
                pinLon, pinLat, pinZ, viewer.scene.globe, greenPoly
              );
              
            } catch (error) {
              console.warn('Error calculating advanced expected strokes:', error);
              // Keep the original expected strokes value
            }
          }
          
          // Update final feature type for counting (including user-defined areas)
          
          // Check if point is in user-defined areas for counting purposes
          try {
            // First check if point is in currently-being-drawn polygon (if it has 3+ points)
            if (currentDrawingType && currentPolygonPoints.length >= 3) {
              const drawingPolygon = currentPolygonPoints.map(p => [p.lon, p.lat]);
              if (isPointInPolygon(lon, lat, drawingPolygon)) {
                // Map drawing type to display category
                if (currentDrawingType === 'hazards') {
                  finalFeatureType = 'user_hazard';
                } else if (currentDrawingType === 'ob') {
                  finalFeatureType = 'user_ob';
                } else {
                  // For other types, use a generic "user_" prefix to distinguish from natural features
                  finalFeatureType = 'user_' + currentDrawingType;
                }
              }
            }
            
            // Then check completed user-defined conditions (if not already found in drawing polygon)
            if (finalFeatureType === courseFeature && userDefinedConditions) {
              // Check all user-defined condition types
              for (const [conditionType, polygons] of Object.entries(userDefinedConditions)) {
                if (polygons && Array.isArray(polygons)) {
                  for (const polygon of polygons) {
                    if (isPointInPolygon(lon, lat, polygon)) {
                      // Map condition type to display category
                      if (conditionType === 'hazards') {
                        finalFeatureType = 'user_hazard';
                      } else if (conditionType === 'ob') {
                        finalFeatureType = 'user_ob';
                      } else {
                        // For other types, use "user_" prefix
                        finalFeatureType = 'user_' + conditionType;
                      }
                      break;
                    }
                  }
                  if (finalFeatureType !== courseFeature) break; // Found a match, stop checking
                }
              }
            }
          } catch (error) {
            console.warn('Error checking user-defined conditions:', error);
          }
          
          // Count condition occurrences
          conditionCounts[finalFeatureType] = (conditionCounts[finalFeatureType] || 0) + 1;
          
          // Debug logging for first few points only
          // Sample logging removed
          
          sumDist += dist;
          sumExpectedStrokes += expectedStrokes;
          count++;

          // Color code the sample points by final feature type (including user-defined areas)
          let pointColor = Cesium.Color.YELLOW.withAlpha(0.6); // default
          
          // Check if advanced short game mode is enabled, distance is ≤ 45 yards, and NOT on the green
          var useAdvancedColors = advancedToggle && advancedToggle.checked && distanceYards <= 45.0 && finalFeatureType !== 'green';
          
          if (useAdvancedColors) {
            // Use advanced short game colors based on modifier value
            try {
              // Get globe for terrain sampling
              const globe = viewer.scene.globe;
              
              // Get pin location for advanced analysis
              const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
              const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
              const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
              // Sample actual terrain height at pin position instead of using height=0
              const pinZ = sampleTerrainCached(globe, pinLon, pinLat);
              
              // Get green polygon for current hole
              const greenPoly = courseFeatures.greenMap.get(String(currentHoleId));
              
              // Calculate advanced expected strokes and get modifier
              // Sample actual terrain height at ball position
              const ballZ = sampleTerrainCached(globe, lon, lat);
              
              const ballLie = analyzeBallLie(lon, lat, ballZ, globe);
              const greenSlope = analyzeGreenSlope(lon, lat, ballZ, pinLon, pinLat, pinZ, globe, greenPoly);
              const elevationChange = analyzeElevationChange(ballZ, pinZ);
              const greenPercent = calculateGreenPercentage(lon, lat, pinLon, pinLat, greenPoly);
              
              const result = getShortGameModifierAndColor(ballLie, greenSlope, elevationChange, greenPercent);
              const modifier = result.modifier;
              const lookupKey = result.key;
              pointColor = result.color;
              
              // Calculate "plays like" distance accounting for elevation (always calculate this)
              const elevationMeters = elevationChange.diff || 0;
              const elevationYards = elevationMeters * 1.09361; // Convert meters to yards
              const playsLikeDistance = distanceYards - elevationYards; // Subtract elevation effect
              
              // Debug logging for SHORT GAME points - DETAILED BREAKDOWN  
              window.debugColorCount = (window.debugColorCount || 0) + 1;
              if (modifier !== 0 || window.debugColorCount <= 10) { // Show more debug info
                console.log(`🏌️ ADVANCED SHORT GAME ANALYSIS - Point ${i + 1}:`);
                console.log(`📍 Position: (${lon.toFixed(6)}, ${lat.toFixed(6)})`);
                console.log(`📏 Distance to Pin: ${distanceYards.toFixed(1)} yards`);
                console.log(`📐 Plays like: ${playsLikeDistance.toFixed(1)} yards`);
                console.log(`⛰️  Ball Lie: ${ballLie.display}`);
                console.log(`🟢 Green Slope: ${greenSlope.display}`);
                console.log(`📈 Elevation Change: ${elevationChange.display}`);
                console.log(`🎯 Green Available: ${greenPercent.display}`);
                console.log(`🔑 Lookup Key: "${lookupKey}"`);
                console.log(`🎮 Modifier Applied: ${modifier > 0 ? '+' : ''}${modifier.toFixed(3)} strokes`);
                console.log(`🔢 Base Expected Strokes: ${baseExpectedStrokes.toFixed(3)}`);
                console.log(`⚡ Advanced Expected Strokes: ${expectedStrokes.toFixed(3)}`);
                console.log(`🎨 Color: R:${pointColor.red.toFixed(2)} G:${pointColor.green.toFixed(2)} B:${pointColor.blue.toFixed(2)}`);
                console.log(`${modifier > 0.05 ? '🔴 HARDER SHOT' : modifier < -0.05 ? '🟢 EASIER SHOT' : '⚪ NEUTRAL SHOT'}`);
                console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
              }
              
            } catch (error) {
              console.warn('Error applying advanced short game colors:', error);
              // Fall back to normal color coding
              useAdvancedColors = false;
            }
          }
          
          if (!useAdvancedColors) {
            // Normal color coding by course feature
            switch (finalFeatureType) {
              case 'water': pointColor = Cesium.Color.AQUAMARINE.withAlpha(0.9); break;
              case 'green': pointColor = Cesium.Color.LIME.withAlpha(0.8); break;
              case 'tee': pointColor = Cesium.Color.LIGHTGRAY.withAlpha(0.8); break;
              case 'fairway': pointColor = Cesium.Color.GREEN.withAlpha(0.7); break;
              case 'rough': pointColor = Cesium.Color.ORANGE.withAlpha(0.6); break;
              case 'sand': pointColor = Cesium.Color.SANDYBROWN.withAlpha(0.8); break;
              case 'recovery': pointColor = Cesium.Color.RED.withAlpha(0.8); break;
              case 'user_hazard': pointColor = Cesium.Color.DARKRED.withAlpha(0.9); break;
              case 'user_ob': pointColor = Cesium.Color.LIGHTGRAY.withAlpha(0.9); break;
              case 'user_water': pointColor = Cesium.Color.DARKBLUE.withAlpha(0.9); break;
              case 'user_bunkers': pointColor = Cesium.Color.CHOCOLATE.withAlpha(0.9); break;
              case 'user_greens': pointColor = Cesium.Color.DARKGREEN.withAlpha(0.9); break;
              case 'user_fairways': pointColor = Cesium.Color.FORESTGREEN.withAlpha(0.9); break;
              case 'user_roughs': pointColor = Cesium.Color.DARKORANGE.withAlpha(0.9); break;
              case 'user_tees': pointColor = Cesium.Color.GRAY.withAlpha(0.9); break;
              case 'user_recovery': pointColor = Cesium.Color.MAROON.withAlpha(0.9); break;
            }
          }

          processedPoints.push({ lon, lat, pointColor });
        }

        // Progressive loading with batches for smoother experience
        clearSamples(); // Clear any existing samples first
        
        // Load samples in batches to maintain 60fps
        const BATCH_SIZE = 100;
        let currentBatch = 0;
        
        function loadNextBatch() {
          try {
            const startIndex = currentBatch * BATCH_SIZE;
            const endIndex = Math.min(startIndex + BATCH_SIZE, processedPoints.length);
            
            // Suspend entity events during batch processing
            viewer.entities.suspendEvents();
          
          for (let i = startIndex; i < endIndex; i++) {
            const point = processedPoints[i];
            let ent;
            
            // Try to get entity from pool, otherwise create new one
            if (window.performanceManager) {
              ent = window.performanceManager.getEntityFromPool('samplePoints', () => {
                return viewer.entities.add({
                  point: { 
                    pixelSize: 3, 
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                    disableDepthTestDistance: 1000,
                    scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.5)
                  }
                });
              });
              
              // Update pooled entity properties
              ent.position = Cesium.Cartesian3.fromDegrees(point.lon, point.lat);
              ent.point.color = point.pointColor;
              ent.show = sampleChk.checked;
            } else {
              // Fallback to direct creation
              ent = viewer.entities.add({
                position: Cesium.Cartesian3.fromDegrees(point.lon, point.lat),
                point: { 
                  pixelSize: 3, 
                  color: point.pointColor, 
                  heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                  disableDepthTestDistance: 1000,
                  scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.5)
                },
                show: sampleChk.checked
              });
            }
            
            sampleEntities.push(ent);
          }
          
          // Resume entity events
          viewer.entities.resumeEvents();
          
          currentBatch++;
          
          // Schedule next batch or finish
          if (endIndex < processedPoints.length) {
            // Use requestAnimationFrame for smooth loading
            requestAnimationFrame(loadNextBatch);
          } else {
            // Force a scene render to ensure clamping is applied
            viewer.scene.requestRender();
            
            // Hide loading indicator
            const loadingIndicator = document.getElementById('sampleLoadingIndicator');
            if (loadingIndicator) loadingIndicator.style.display = 'none';
          }
          
          } catch (error) {
            console.warn('Error during sample batch loading:', error);
            
            // Resume events even on error
            try {
              viewer.entities.resumeEvents();
            } catch (resumeError) {
              console.warn('Error resuming entity events:', resumeError);
            }
            
            // Hide loading indicator
            const loadingIndicator = document.getElementById('sampleLoadingIndicator');
            if (loadingIndicator) loadingIndicator.style.display = 'none';
            
            // Try to continue with next batch or stop gracefully
            currentBatch++;
            if (currentBatch * BATCH_SIZE < processedPoints.length) {
              setTimeout(() => requestAnimationFrame(loadNextBatch), 100);
            }
          }
        }
        
        // Start loading after terrain is ready using proper Cesium timing
        const startLoading = () => {
          // Remove this listener after first use
          viewer.scene.postRender.removeEventListener(startLoading);
          // Small delay to ensure terrain processing is complete
          requestAnimationFrame(loadNextBatch);
        };
        
        // Wait for next render cycle, then start loading
        viewer.scene.postRender.addEventListener(startLoading);
        
        // Update displays
        document.getElementById('avgDistDisplay').textContent = count ? formatDistance(sumDist / count) : '--';
        
        // Add expected strokes display with basic vs advanced comparison
        const avgExpectedStrokes = count ? (sumExpectedStrokes / count) : 0;
        let expectedStrokesDisplay = document.getElementById('expectedStrokesDisplay');
        if (!expectedStrokesDisplay) {
          // Create the display element if it doesn't exist
          const avgProximityDiv = document.getElementById('avgDistDisplay').parentElement;
          const newDiv = avgProximityDiv.cloneNode(true);
          newDiv.querySelector('.display-label').textContent = 'Expected Strokes Remaining';
          newDiv.querySelector('.distance-value').id = 'expectedStrokesDisplay';
          newDiv.querySelector('.distance-value').textContent = '--';
          avgProximityDiv.parentElement.appendChild(newDiv);
          expectedStrokesDisplay = document.getElementById('expectedStrokesDisplay');
        }
        
        // Check if advanced short game is enabled to show comparison
        if (advancedToggle && advancedToggle.checked) {
          // Show advanced value with indicator
          expectedStrokesDisplay.textContent = count ? `${avgExpectedStrokes.toFixed(2)} ⚡` : '--';
          expectedStrokesDisplay.title = `Advanced short game modifiers applied for shots ≤45 yards`;
        } else {
          expectedStrokesDisplay.textContent = count ? avgExpectedStrokes.toFixed(2) : '--';
          expectedStrokesDisplay.title = `Basic expected strokes calculation`;
        }
        
        // Update condition breakdown chart
        updateConditionChart(conditionCounts, count);
        
        // Advanced short game summary
        if (isAdvancedEnabled) {
          const shortGamePoints = processedPoints.filter(p => {
            const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
            const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
            const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
            
            const geod = new Cesium.EllipsoidGeodesic();
            geod.setEndPoints(Cesium.Cartographic.fromDegrees(pinLon, pinLat), Cesium.Cartographic.fromDegrees(p.lon, p.lat));
            const dist = geod.surfaceDistance * 1.09361; // Convert to yards
            return dist <= 45.0;
          }).length;
          
          console.log('🏌️ ADVANCED SHORT GAME SUMMARY:');
          console.log(`📊 Total sample points: ${count}`);
          console.log(`🎯 Points in short game range (≤45yd): ${shortGamePoints}`);
          console.log(`⚡ Advanced modifiers applied to: ${shortGamePoints} points`);
          console.log('━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━');
        }
        
        updateSampleVisibility();
      }

      function updateConditionChart(conditionCounts, totalCount) {
        let conditionChartDiv = document.getElementById('conditionChart');
        if (!conditionChartDiv) {
          // Create the chart container after the avg proximity display
          const avgProximityDiv = document.getElementById('avgDistDisplay').parentElement;
          const chartDiv = document.createElement('div');
          chartDiv.id = 'conditionChart';
          chartDiv.style.marginTop = '10px';
          chartDiv.style.fontSize = '12px';
          chartDiv.innerHTML = '<div style="font-weight: bold; margin-bottom: 5px;">Condition Breakdown:</div>';
          avgProximityDiv.parentElement.insertAdjacentElement('afterend', chartDiv);
          conditionChartDiv = chartDiv;
        }
        
        // Clear existing content except title
        const title = conditionChartDiv.firstElementChild;
        conditionChartDiv.innerHTML = '';
        conditionChartDiv.appendChild(title);
        
        if (totalCount === 0) {
          conditionChartDiv.innerHTML += '<div>No samples</div>';
          return;
        }
        
        // Calculate percentages and create visual bars
        const conditionColors = {
          water: '#40E0D0',      // Aquamarine
          sand: '#F4A460',       // Sandy brown
          green: '#32CD32',      // Lime green
          tee: '#D3D3D3',        // Light gray
          fairway: '#228B22',    // Forest green
          rough: '#FF8C00',      // Orange
          recovery: '#FF0000',   // Red
          user_hazard: '#8B0000', // Dark red
          user_ob: '#A9A9A9',    // Dark gray
          user_water: '#00008B',  // Dark blue
          user_bunkers: '#D2691E', // Chocolate
          user_greens: '#006400',  // Dark green
          user_fairways: '#228B22', // Forest green
          user_roughs: '#FF4500',   // Dark orange
          user_tees: '#808080',     // Gray
          user_recovery: '#800000'  // Maroon
        };
        
        const conditionLabels = {
          water: 'Water',
          sand: 'Bunker',
          green: 'Green',
          tee: 'Tee',
          fairway: 'Fairway',
          rough: 'Rough',
          recovery: 'Recovery',
          user_hazard: 'User Hazard',
          user_ob: 'User OB',
          user_water: 'User Water',
          user_bunkers: 'User Bunkers',
          user_greens: 'User Green',
          user_fairways: 'User Fairway',
          user_roughs: 'User Rough',
          user_tees: 'User Tee',
          user_recovery: 'User Recovery'
        };
        
        // Sort conditions by count (descending)
        const sortedConditions = Object.entries(conditionCounts)
          .filter(([condition, count]) => count > 0)
          .sort((a, b) => b[1] - a[1]);
        
        for (const [condition, count] of sortedConditions) {
          const percentage = ((count / totalCount) * 100).toFixed(1);
          const barWidth = Math.max(percentage, 1); // Minimum 1% width for visibility
          
          const barDiv = document.createElement('div');
          barDiv.style.display = 'flex';
          barDiv.style.alignItems = 'center';
          barDiv.style.marginBottom = '2px';
          barDiv.innerHTML = `
            <div style="width: 60px; font-size: 11px;">${conditionLabels[condition] || condition}:</div>
            <div style="width: 80px; height: 12px; background-color: #ddd; margin: 0 5px; border-radius: 2px; overflow: hidden;">
              <div style="width: ${barWidth}%; height: 100%; background-color: ${conditionColors[condition] || '#CCCCCC'};"></div>
            </div>
            <div style="font-size: 11px;">${percentage}% (${count})</div>
          `;
          conditionChartDiv.appendChild(barDiv);
        }
      }

      function computeHeadingDeg(fromLon, fromLat, toLon, toLat) {
        const φ1 = Cesium.Math.toRadians(fromLat);
        const φ2 = Cesium.Math.toRadians(toLat);
        const λ1 = Cesium.Math.toRadians(fromLon);
        const λ2 = Cesium.Math.toRadians(toLon);
        const y = Math.sin(λ2 - λ1) * Math.cos(φ2);
        const x = Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(λ2 - λ1);
        let brng = Cesium.Math.toDegrees(Math.atan2(y, x));
        brng = (brng + 360) % 360;
        return brng;
      }

      function getBaseHeadingDeg() {
        if (!launchEntity) return 0;
        const jd = Cesium.JulianDate.now();
        const carto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(jd));
        const lLon = Cesium.Math.toDegrees(carto.longitude);
        const lLat = Cesium.Math.toDegrees(carto.latitude);
        return computeHeadingDeg(lLon, lLat, centerLon, centerLat);
      }

      async function autoSizeFromSkill() {
        sizingFromSkill = true;
        if (skillSel.value === 'custom') { sizingFromSkill = false; return; }
        if (!launchEntity) return;
        
        let skill;
        if (skillSel.value === 'jack') {
          const off = parseFloat(jackOfflineEl.value) || 0;
          const pct = (parseFloat(jackDistPctEl.value) || 0) / 100.0;
          skill = { offlineDeg: off, distPct: pct };
        } else {
          skill = SKILL[skillSel.value];
        }

        const geod = new Cesium.EllipsoidGeodesic();
        const launchCarto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(Cesium.JulianDate.now()));
        const lLon = Cesium.Math.toDegrees(launchCarto.longitude);
        const lLat = Cesium.Math.toDegrees(launchCarto.latitude);

        // Intended distance: launch to aim point (oval center)
        geod.setEndPoints(
          Cesium.Cartographic.fromDegrees(lLon, lLat),
          Cesium.Cartographic.fromDegrees(centerLon, centerLat)
        );
        const intendedDist = geod.surfaceDistance;
        
        // Batch terrain sampling for all positions at once (PERFORMANCE OPTIMIZATION)
        try {
          // First sample the launch position to get accurate tee height
          const launchTerrainSample = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [new Cesium.Cartographic(launchCarto.longitude, launchCarto.latitude, 0)]
          );
          const teeHeight = launchTerrainSample[0].height || 0;
          console.log(`Tee height sampled: ${teeHeight.toFixed(1)}m`);
          
          const positionsToSample = [
            new Cesium.Cartographic(Cesium.Math.toRadians(centerLon), Cesium.Math.toRadians(centerLat), 0) // Oval center
          ];
          
          let pinLon, pinLat, shotDist;
          if (pinEntity) {
            const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
            pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
            pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
            
            geod.setEndPoints(
              Cesium.Cartographic.fromDegrees(lLon, lLat),
              Cesium.Cartographic.fromDegrees(pinLon, pinLat)
            );
            shotDist = geod.surfaceDistance;
            
            // Add pin position to batch sampling
            positionsToSample.push(
              new Cesium.Cartographic(Cesium.Math.toRadians(pinLon), Cesium.Math.toRadians(pinLat), 0)
            );
          }
          
          // Single batched terrain sampling call
          const sampledPositions = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            positionsToSample
          );
          
          // Process intended distance elevation (always first sample)
          const ovalHeight = sampledPositions[0].height || 0;
          const ovalElevationChange = ovalHeight - teeHeight;
          const ovalElevationYards = ovalElevationChange * 1.09361;
          
          const ovalElevationText = ovalElevationYards >= 0 
            ? `+${Math.abs(ovalElevationYards).toFixed(0)}y`
            : `-${Math.abs(ovalElevationYards).toFixed(0)}y`;
            
          document.getElementById('intendedDistDisplay').innerHTML = 
            `${formatDistance(intendedDist)}<br><span style="font-size: 10px; color: #888;">${ovalElevationText}</span>`;
          
          // Process shot distance elevation (second sample, if pin exists)
          if (pinEntity && sampledPositions.length > 1) {
            const pinHeight = sampledPositions[1].height || 0;
            const pinElevationChange = pinHeight - teeHeight;
            const pinElevationYards = pinElevationChange * 1.09361;
            
            const pinElevationText = pinElevationYards >= 0 
              ? `+${Math.abs(pinElevationYards).toFixed(0)}y`
              : `-${Math.abs(pinElevationYards).toFixed(0)}y`;
              
            document.getElementById('shotDistDisplay').innerHTML = 
              `${formatDistance(shotDist)}<br><span style="font-size: 10px; color: #888;">${pinElevationText}</span>`;
          } else {
            document.getElementById('shotDistDisplay').textContent = '--';
          }
          
        } catch (error) {
          console.warn('Failed to calculate elevations with batched terrain sampling:', error);
          // Fallback to distance only
          document.getElementById('intendedDistDisplay').textContent = formatDistance(intendedDist);
          if (pinEntity) {
            const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
            const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
            const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
            
            geod.setEndPoints(
              Cesium.Cartographic.fromDegrees(lLon, lLat),
              Cesium.Cartographic.fromDegrees(pinLon, pinLat)
            );
            const shotDist = geod.surfaceDistance;
            document.getElementById('shotDistDisplay').textContent = formatDistance(shotDist);
          } else {
            document.getElementById('shotDistDisplay').textContent = '--';
          }
        }

        const theta = Cesium.Math.toRadians(skill.offlineDeg);
        const halfWidth = Math.tan(theta) * intendedDist;
        const width = 2 * halfWidth;
        const depth = 2 * (skill.distPct * intendedDist);

        // Update global oval dimensions with calculated values
        ovalWidth = Math.max(5, width); // Minimum 5 meters width
        ovalDepth = Math.max(3, depth); // Minimum 3 meters depth
        
        console.log(`Auto-sized oval for ${formatDistance(intendedDist)} shot: ${ovalWidth.toFixed(1)}m x ${ovalDepth.toFixed(1)}m`);
        
        rebuildOval();
        generateRandomPoints();
        sizingFromSkill = false;
      }

      // ==================== AIM POINT OPTIMIZATION ENGINE ====================
      
      // Global optimization variables
      let optimizationInProgress = false;
      let optimizationCandidates = [];
      let candidateEntities = [];
      let maxDriveDistance = 274.32; // Default max drive: 300 yards in meters
      
      // User-defined course conditions (all stored as polygon arrays)
      let userDefinedConditions = {
        water: [],      // Blue polygons - water hazard expected strokes
        bunkers: [],    // Sandy polygons - sand expected strokes  
        greens: [],     // Green polygons - green expected strokes
        tees: [],       // Gray polygons - tee expected strokes
        fairways: [],   // Green polygons - fairway expected strokes
        roughs: [],     // Orange polygons - rough expected strokes
        hazards: [],    // Red polygons - rough + 1 stroke
        ob: [],         // White polygons - rough + 2 strokes
        recovery: []    // Purple polygons - recovery expected strokes
      };
      
      // Drawing state
      let currentDrawingType = null;
      let currentPolygonPoints = [];
      let drawingPolygonEntity = null;
      let conditionHistory = []; // Track order of added conditions for "Clear Last" functionality
      let conditionEntities = []; // Track visual entities for each condition
      
      // Enhanced expected strokes calculation with user-defined course conditions
      function calculateExpectedStrokesWithPenalties(distanceYards, lon, lat) {
        try {
          // Check user-defined conditions in priority order
          
          // First check if point is in currently-being-drawn polygon (if it has 3+ points)
          if (currentDrawingType && currentPolygonPoints.length >= 3) {
            // Convert current drawing points to simple array format for polygon checking
            const drawingPolygon = currentPolygonPoints.map(p => [p.lon, p.lat]);
            if (isPointInPolygon(lon, lat, drawingPolygon)) {
              // Handle special penalty conditions for currently-being-drawn polygon
              if (currentDrawingType === 'hazards') {
                const roughStrokes = calculateExpectedStrokes(distanceYards, 'rough');
                return roughStrokes + 1; // Hazard penalty
              } else if (currentDrawingType === 'ob') {
                const roughStrokes = calculateExpectedStrokes(distanceYards, 'rough');
                return roughStrokes + 2; // OB penalty
              } else {
                // Map drawing type to expected strokes calculation
                let featureType = currentDrawingType;
                if (currentDrawingType === 'bunkers') featureType = 'sand';
                if (currentDrawingType === 'greens') featureType = 'green';
                if (currentDrawingType === 'fairways') featureType = 'fairway';
                if (currentDrawingType === 'roughs') featureType = 'rough';
                if (currentDrawingType === 'tees') featureType = 'tee';
                if (currentDrawingType === 'water') featureType = 'water';
                if (currentDrawingType === 'recovery') featureType = 'recovery';
                
                return calculateExpectedStrokes(distanceYards, featureType);
              }
            }
          }
          
          // Then check for completed user-defined course conditions (override natural features)
          for (const [conditionType, polygons] of Object.entries(userDefinedConditions)) {
            if (polygons && Array.isArray(polygons)) {
              for (const polygon of polygons) {
                if (isPointInPolygon(lon, lat, polygon)) {
                  // Handle special penalty conditions
                  if (conditionType === 'hazards') {
                    const roughStrokes = calculateExpectedStrokes(distanceYards, 'rough');
                    return roughStrokes + 1; // Hazard penalty
                  } else if (conditionType === 'ob') {
                    const roughStrokes = calculateExpectedStrokes(distanceYards, 'rough');
                    return roughStrokes + 2; // OB penalty
                  } else {
                    // Map condition type to expected strokes calculation
                    let featureType = conditionType;
                    if (conditionType === 'bunkers') featureType = 'sand';
                    if (conditionType === 'greens') featureType = 'green';
                    if (conditionType === 'fairways') featureType = 'fairway';
                    if (conditionType === 'roughs') featureType = 'rough';
                    if (conditionType === 'tees') featureType = 'tee';
                    if (conditionType === 'water') featureType = 'water';
                    if (conditionType === 'recovery') featureType = 'recovery';
                    
                    return calculateExpectedStrokes(distanceYards, featureType);
                  }
                }
              }
            }
          }
          
          // If not in any user-defined area, use natural course feature detection
          const courseFeature = identifyCourseFeature(lon, lat);
          return calculateExpectedStrokes(distanceYards, courseFeature);
          
        } catch (error) {
          console.warn('Error calculating expected strokes with penalties:', error);
          // Fallback to basic calculation
          const courseFeature = identifyCourseFeature(lon, lat);
          return calculateExpectedStrokes(distanceYards, courseFeature);
        }
      }
      
      // Point-in-polygon test for user-defined areas
      function isPointInPolygon(lon, lat, polygon) {
        if (!polygon || !Array.isArray(polygon) || polygon.length < 3) {
          return false;
        }
        
        let inside = false;
        for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
          if (((polygon[i].lat > lat) !== (polygon[j].lat > lat)) &&
              (lon < (polygon[j].lon - polygon[i].lon) * (lat - polygon[i].lat) / (polygon[j].lat - polygon[i].lat) + polygon[i].lon)) {
            inside = !inside;
          }
        }
        return inside;
      }
      
      // Fast expected strokes evaluation for optimization (reduced sample count)
      async function evaluateAimPoint(aimLon, aimLat) {
        if (!pinEntity || !launchEntity) return Infinity;
        
        const geod = new Cesium.EllipsoidGeodesic();
        const launchCarto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(Cesium.JulianDate.now()));
        const lLon = Cesium.Math.toDegrees(launchCarto.longitude);
        const lLat = Cesium.Math.toDegrees(launchCarto.latitude);
        
        // Check distance constraint
        geod.setEndPoints(
          Cesium.Cartographic.fromDegrees(lLon, lLat),
          Cesium.Cartographic.fromDegrees(aimLon, aimLat)
        );
        const shotDistance = geod.surfaceDistance;
        
        // Calculate elevation-adjusted max distance
        const useYards = unitsChk.checked;
        const displayValue = parseFloat(maxDriveToolbar.value);
        const baseMaxDistanceMeters = useYards ? displayValue * 0.9144 : displayValue;
        
        // Get elevation difference for "plays like" calculation
        const launchHeight = sampleTerrainCached(viewer.scene.globe, lLon, lLat);
        const aimHeight = sampleTerrainCached(viewer.scene.globe, aimLon, aimLat);
        const elevationDiff = aimHeight - launchHeight; // Positive = uphill, Negative = downhill
        
        // Adjust max distance for elevation: subtract elevation effect to get "plays like" distance
        // Player can still hit their normal distance in "effective" terms
        const elevationEffectMeters = elevationDiff; // 1m elevation ≈ 1m distance effect
        const effectiveMaxDistance = baseMaxDistanceMeters + elevationEffectMeters;
        
        // Debug elevation adjustment (first few times)
        if (!window.elevationAdjustDebugCount || window.elevationAdjustDebugCount < 5) {
          window.elevationAdjustDebugCount = (window.elevationAdjustDebugCount || 0) + 1;
          const elevationYards = elevationDiff * 1.09361;
          const baseYards = baseMaxDistanceMeters * 1.09361;
          const effectiveYards = effectiveMaxDistance * 1.09361;
          console.log(`🎯 ELEVATION OPTIMIZATION DEBUG #${window.elevationAdjustDebugCount}:`);
          console.log(`   Launch height: ${launchHeight.toFixed(1)}m, Aim height: ${aimHeight.toFixed(1)}m`);
          console.log(`   Elevation diff: ${elevationDiff.toFixed(1)}m (${elevationYards.toFixed(1)}y)`);
          console.log(`   Base max: ${baseYards.toFixed(0)}y, Effective max: ${effectiveYards.toFixed(0)}y`);
          console.log(`   Shot distance: ${(shotDistance * 1.09361).toFixed(1)}y`);
        }
        
        if (shotDistance > effectiveMaxDistance) {
          return Infinity; // Outside effective max distance
        }
        
        // Use current skill level for dispersion calculation
        let skill;
        if (skillSel.value === 'jack') {
          const off = parseFloat(jackOfflineEl.value) || 0;
          const pct = (parseFloat(jackDistPctEl.value) || 0) / 100.0;
          skill = { offlineDeg: off, distPct: pct };
        } else {
          skill = SKILL[skillSel.value];
        }
        
        // Calculate dispersion oval dimensions for this aim point
        const theta = Cesium.Math.toRadians(skill.offlineDeg);
        const halfWidth = Math.tan(theta) * shotDistance;
        const width = 2 * halfWidth;
        const depth = 2 * (skill.distPct * shotDistance);
        
        const semiMajor = Math.max(width, depth) / 2;
        const semiMinor = Math.min(width, depth) / 2;
        const rotDeg = ((360 - computeHeadingDeg(lLon, lLat, aimLon, aimLat)) + 0) % 360;
        const rotRad = Cesium.Math.toRadians(rotDeg);
        const cosR = Math.cos(rotRad), sinR = Math.sin(rotRad);
        const mPerLon = metersPerDegLonAt(aimLat);
        
        const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
        const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
        const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
        
        // Generate improved sample set for optimization (300 points for better accuracy)
        let sumExpectedStrokes = 0;
        let count = 0;
        
        for (let i = 0; i < 300; i++) {
          const { x, y } = randomPointInEllipse(semiMajor, semiMinor);
          const xr = x * cosR - y * sinR;
          const yr = x * sinR + y * cosR;
          const lon = aimLon + xr / mPerLon;
          const lat = aimLat + yr / metersPerDegLat;
          
          // Calculate distance to pin
          geod.setEndPoints(Cesium.Cartographic.fromDegrees(pinLon, pinLat), Cesium.Cartographic.fromDegrees(lon, lat));
          const dist = geod.surfaceDistance;
          const distanceYards = dist * 1.09361;
          
          // Calculate expected strokes with user penalties
          const expectedStrokes = calculateExpectedStrokesWithPenalties(distanceYards, lon, lat);
          
          if (expectedStrokes !== null && expectedStrokes !== Infinity) {
            sumExpectedStrokes += expectedStrokes;
            count++;
          }
        }
        
        return count > 0 ? (sumExpectedStrokes / count) : Infinity;
      }

      // Full sample evaluation for final verification (uses 600 points like display)
      async function evaluateAimPointFullSample(aimLon, aimLat) {
        if (!pinEntity || !launchEntity) return Infinity;
        
        const geod = new Cesium.EllipsoidGeodesic();
        const launchCarto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(Cesium.JulianDate.now()));
        const lLon = Cesium.Math.toDegrees(launchCarto.longitude);
        const lLat = Cesium.Math.toDegrees(launchCarto.latitude);
        
        // Check distance constraint
        geod.setEndPoints(
          Cesium.Cartographic.fromDegrees(lLon, lLat),
          Cesium.Cartographic.fromDegrees(aimLon, aimLat)
        );
        const shotDistance = geod.surfaceDistance;
        
        // Calculate elevation-adjusted max distance
        const useYards = unitsChk.checked;
        const displayValue = parseFloat(maxDriveToolbar.value);
        const baseMaxDistanceMeters = useYards ? displayValue * 0.9144 : displayValue;
        
        // Get elevation difference for "plays like" calculation
        const launchHeight = sampleTerrainCached(viewer.scene.globe, lLon, lLat);
        const aimHeight = sampleTerrainCached(viewer.scene.globe, aimLon, aimLat);
        const elevationDiff = aimHeight - launchHeight; // Positive = uphill, Negative = downhill
        
        // Adjust max distance for elevation
        const elevationEffectMeters = elevationDiff; // 1m elevation ≈ 1m distance effect
        const effectiveMaxDistance = baseMaxDistanceMeters + elevationEffectMeters;
        
        if (shotDistance > effectiveMaxDistance) {
          return Infinity; // Outside effective max distance
        }
        
        // Use current skill level
        let skill;
        if (skillSel.value === 'jack') {
          const off = parseFloat(jackOfflineEl.value) || 0;
          const pct = (parseFloat(jackDistPctEl.value) || 0) / 100.0;
          skill = { offlineDeg: off, distPct: pct };
        } else {
          skill = SKILL[skillSel.value];
        }
        
        // Calculate dispersion oval dimensions
        const theta = Cesium.Math.toRadians(skill.offlineDeg);
        const halfWidth = Math.tan(theta) * shotDistance;
        const width = 2 * halfWidth;
        const depth = 2 * (skill.distPct * shotDistance);
        
        const semiMajor = Math.max(width, depth) / 2;
        const semiMinor = Math.min(width, depth) / 2;
        const rotDeg = ((360 - computeHeadingDeg(lLon, lLat, aimLon, aimLat)) + 0) % 360;
        const rotRad = Cesium.Math.toRadians(rotDeg);
        const cosR = Math.cos(rotRad), sinR = Math.sin(rotRad);
        const mPerLon = metersPerDegLonAt(aimLat);
        
        const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
        const pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
        const pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
        
        // Generate FULL sample set (600 points like the display)
        let sumExpectedStrokes = 0;
        let count = 0;
        
        for (let i = 0; i < 600; i++) {
          const { x, y } = randomPointInEllipse(semiMajor, semiMinor);
          const xr = x * cosR - y * sinR;
          const yr = x * sinR + y * cosR;
          const lon = aimLon + xr / mPerLon;
          const lat = aimLat + yr / metersPerDegLat;
          
          geod.setEndPoints(Cesium.Cartographic.fromDegrees(pinLon, pinLat), Cesium.Cartographic.fromDegrees(lon, lat));
          const dist = geod.surfaceDistance;
          const distanceYards = dist * 1.09361;
          
          const expectedStrokes = calculateExpectedStrokesWithPenalties(distanceYards, lon, lat);
          
          if (expectedStrokes !== null && expectedStrokes !== Infinity) {
            sumExpectedStrokes += expectedStrokes;
            count++;
          }
        }
        
        return count > 0 ? (sumExpectedStrokes / count) : Infinity;
      }
      
      // Multi-stage circular optimization algorithm
      async function optimizeAimPoint() {
        if (optimizationInProgress || !launchEntity || !pinEntity) {
          console.warn('Cannot optimize: missing launch point or pin, or optimization already in progress');
          return;
        }
        
        optimizationInProgress = true;
        clearOptimizationCandidates();
        
        console.log('Starting advanced 3-stage aim point optimization...');
        const startTime = performance.now();
        
        const geod = new Cesium.EllipsoidGeodesic();
        const launchCarto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(Cesium.JulianDate.now()));
        const lLon = Cesium.Math.toDegrees(launchCarto.longitude);
        const lLat = Cesium.Math.toDegrees(launchCarto.latitude);
        
        // Calculate base max distance in meters  
        const useYards = unitsChk.checked;
        const displayValue = parseFloat(maxDriveToolbar.value);
        const baseMaxDistanceMeters = useYards ? displayValue * 0.9144 : displayValue;
        
        console.log(`Optimization: Base Distance=${displayValue}${useYards ? 'y' : 'm'} (${baseMaxDistanceMeters.toFixed(1)}m)`);
        
        // Note: Elevation adjustments will be calculated per aim point during optimization
        // Use base distance for initial search radius
        const maxDistDegreesLon = baseMaxDistanceMeters / (111000 * Math.cos(Cesium.Math.toRadians(lLat)));
        const maxDistDegreesLat = baseMaxDistanceMeters / 111000;
        
        let allCandidates = [];
        let evaluationsCompleted = 0;
        
        // ========== STAGE 1: Coarse Circular Grid (Higher Resolution) ==========
        console.log('Stage 1: Coarse circular grid search...');
        const stage1RadialRings = 15;  // Number of distance rings
        const stage1AngularDivisions = 24; // Points per ring (every 15 degrees)
        const stage1Candidates = [];
        
        for (let ring = 1; ring <= stage1RadialRings; ring++) {
          const ringRadius = (ring / stage1RadialRings) * actualMaxDistanceMeters;
          const ringRadiusLon = ringRadius / (111000 * Math.cos(Cesium.Math.toRadians(lLat)));
          const ringRadiusLat = ringRadius / 111000;
          
          const angularStep = 360 / stage1AngularDivisions;
          const batchPromises = [];
          
          for (let angle = 0; angle < 360; angle += angularStep) {
            const angleRad = Cesium.Math.toRadians(angle);
            const aimLon = lLon + ringRadiusLon * Math.cos(angleRad);
            const aimLat = lLat + ringRadiusLat * Math.sin(angleRad);
            
            batchPromises.push(
              evaluateAimPoint(aimLon, aimLat).then(expectedStrokes => {
                evaluationsCompleted++;
                if (expectedStrokes !== Infinity) {
                  return { lon: aimLon, lat: aimLat, expectedStrokes: expectedStrokes };
                }
                return null;
              })
            );
          }
          
          const batchResults = await Promise.all(batchPromises);
          stage1Candidates.push(...batchResults.filter(result => result !== null));
          
          // Progress update
          if (ring % 3 === 0) {
            console.log(`Stage 1: Ring ${ring}/${stage1RadialRings}, ${evaluationsCompleted} evaluations`);
          }
          
          // Allow UI to update
          await new Promise(resolve => setTimeout(resolve, 5));
        }
        
        console.log(`Stage 1: Evaluated ${stage1Candidates.length} candidates from ${evaluationsCompleted} points`);
        allCandidates.push(...stage1Candidates);
        
        // ========== STAGE 2: Fine Local Search Around Best Candidates ==========
        console.log('Stage 2: Fine local search around best candidates...');
        
        // Sort stage 1 results and take top candidates for refinement
        stage1Candidates.sort((a, b) => a.expectedStrokes - b.expectedStrokes);
        const topCandidatesForRefinement = stage1Candidates.slice(0, Math.min(10, stage1Candidates.length));
        
        const stage2Candidates = [];
        
        for (const baseCandidate of topCandidatesForRefinement) {
          // Create fine grid around this candidate
          const refinementRadius = actualMaxDistanceMeters * 0.05; // 5% of max distance
          const refinementSteps = 8; // 8x8 local grid
          
          const refRadLon = refinementRadius / (111000 * Math.cos(Cesium.Math.toRadians(lLat)));
          const refRadLat = refinementRadius / 111000;
          
          const batchPromises = [];
          
          for (let i = -refinementSteps; i <= refinementSteps; i++) {
            for (let j = -refinementSteps; j <= refinementSteps; j++) {
              if (i === 0 && j === 0) continue; // Skip center point (already evaluated)
              
              const aimLon = baseCandidate.lon + (i / refinementSteps) * refRadLon;
              const aimLat = baseCandidate.lat + (j / refinementSteps) * refRadLat;
              
              // Check if within max distance
              const distFromLaunch = Math.sqrt(
                Math.pow((aimLon - lLon) * 111000 * Math.cos(Cesium.Math.toRadians(lLat)), 2) +
                Math.pow((aimLat - lLat) * 111000, 2)
              );
              
              if (distFromLaunch <= actualMaxDistanceMeters) {
                batchPromises.push(
                  evaluateAimPoint(aimLon, aimLat).then(expectedStrokes => {
                    evaluationsCompleted++;
                    if (expectedStrokes !== Infinity) {
                      return { lon: aimLon, lat: aimLat, expectedStrokes: expectedStrokes };
                    }
                    return null;
                  })
                );
              }
            }
          }
          
          if (batchPromises.length > 0) {
            const batchResults = await Promise.all(batchPromises);
            stage2Candidates.push(...batchResults.filter(result => result !== null));
          }
        }
        
        console.log(`Stage 2: Evaluated ${stage2Candidates.length} refinement candidates`);
        allCandidates.push(...stage2Candidates);
        
        // ========== STAGE 3: Random Sampling for Coverage ==========
        console.log('Stage 3: Random sampling for comprehensive coverage...');
        
        const stage3Samples = 500; // Additional random samples
        const stage3Candidates = [];
        const batchSize = 25;
        
        for (let batch = 0; batch < Math.ceil(stage3Samples / batchSize); batch++) {
          const batchPromises = [];
          const batchStart = batch * batchSize;
          const batchEnd = Math.min(batchStart + batchSize, stage3Samples);
          
          for (let i = batchStart; i < batchEnd; i++) {
            // Generate random point within max distance using polar coordinates
            const randomAngle = Math.random() * 2 * Math.PI;
            const randomRadius = Math.sqrt(Math.random()) * actualMaxDistanceMeters; // sqrt for uniform distribution
            
            const aimLon = lLon + (randomRadius * Math.cos(randomAngle)) / (111000 * Math.cos(Cesium.Math.toRadians(lLat)));
            const aimLat = lLat + (randomRadius * Math.sin(randomAngle)) / 111000;
            
            batchPromises.push(
              evaluateAimPoint(aimLon, aimLat).then(expectedStrokes => {
                evaluationsCompleted++;
                if (expectedStrokes !== Infinity) {
                  return { lon: aimLon, lat: aimLat, expectedStrokes: expectedStrokes };
                }
                return null;
              })
            );
          }
          
          const batchResults = await Promise.all(batchPromises);
          stage3Candidates.push(...batchResults.filter(result => result !== null));
          
          // Allow UI to update
          await new Promise(resolve => setTimeout(resolve, 5));
        }
        
        console.log(`Stage 3: Evaluated ${stage3Candidates.length} random samples`);
        allCandidates.push(...stage3Candidates);
        
        const totalEvaluations = evaluationsCompleted;
        
        // ========== FINAL PROCESSING: Smart Candidate Selection ==========
        console.log(`Optimization complete: ${totalEvaluations} total evaluations`);
        
        // Sort all candidates by expected strokes (best first)
        allCandidates.sort((a, b) => a.expectedStrokes - b.expectedStrokes);
        
        // Improved candidate selection strategy
        const filteredCandidates = [];
        const minSeparationYards = 3; // Minimum 3 yards between candidates for meaningful choices
        const minSeparationMeters = minSeparationYards * 0.9144;
        
        if (allCandidates.length > 0) {
          // Always include the absolute best candidate
          filteredCandidates.push(allCandidates[0]);
          const bestScore = allCandidates[0].expectedStrokes;
          
          // Dynamic quality threshold based on best score
          // For very good positions (< 3.0 strokes), be more selective
          // For harder positions (> 4.0 strokes), be more liberal
          const dynamicThreshold = bestScore < 3.0 ? 0.05 : 
                                   bestScore < 4.0 ? 0.1 : 0.2;
          
          console.log(`Best score: ${bestScore.toFixed(3)}, Quality threshold: ${dynamicThreshold.toFixed(3)}`);
          
          // Find diverse high-quality candidates
          for (let i = 1; i < allCandidates.length && filteredCandidates.length < 8; i++) {
            const candidate = allCandidates[i];
            
            // Quality filter - more flexible than before
            if (candidate.expectedStrokes > bestScore + dynamicThreshold) {
              // If we have few candidates, relax the threshold slightly
              if (filteredCandidates.length < 3 && candidate.expectedStrokes <= bestScore + dynamicThreshold * 1.5) {
                // Continue to spatial filtering
              } else {
                continue;
              }
            }
            
            // Spatial diversity filter
            let tooClose = false;
            for (const selected of filteredCandidates) {
              const geod = new Cesium.EllipsoidGeodesic();
              geod.setEndPoints(
                Cesium.Cartographic.fromDegrees(candidate.lon, candidate.lat),
                Cesium.Cartographic.fromDegrees(selected.lon, selected.lat)
              );
              const distance = geod.surfaceDistance;
              
              if (distance < minSeparationMeters) {
                tooClose = true;
                break;
              }
            }
            
            if (!tooClose) {
              filteredCandidates.push(candidate);
            }
          }
          
          // If we still have very few candidates, add some with relaxed constraints
          if (filteredCandidates.length < 3) {
            const relaxedThreshold = bestScore + 0.3; // Much more liberal
            const relaxedSeparation = minSeparationMeters * 0.5; // Closer together allowed
            
            for (let i = 1; i < allCandidates.length && filteredCandidates.length < 5; i++) {
              const candidate = allCandidates[i];
              
              if (candidate.expectedStrokes > relaxedThreshold) continue;
              
              // Check if this candidate is already included
              const alreadyIncluded = filteredCandidates.some(selected => 
                Math.abs(selected.lon - candidate.lon) < 0.0001 && 
                Math.abs(selected.lat - candidate.lat) < 0.0001
              );
              
              if (alreadyIncluded) continue;
              
              let tooClose = false;
              for (const selected of filteredCandidates) {
                const geod = new Cesium.EllipsoidGeodesic();
                geod.setEndPoints(
                  Cesium.Cartographic.fromDegrees(candidate.lon, candidate.lat),
                  Cesium.Cartographic.fromDegrees(selected.lon, selected.lat)
                );
                const distance = geod.surfaceDistance;
                
                if (distance < relaxedSeparation) {
                  tooClose = true;
                  break;
                }
              }
              
              if (!tooClose) {
                filteredCandidates.push(candidate);
              }
            }
          }
        }
        
        // FINAL VERIFICATION: Re-evaluate top candidates with full 600-point sampling
        console.log('Final verification: Re-evaluating top candidates with full sampling...');
        for (let i = 0; i < Math.min(filteredCandidates.length, 7); i++) {
          const candidate = filteredCandidates[i];
          const originalScore = candidate.expectedStrokes;
          const fullSampleResult = await evaluateAimPointFullSample(candidate.lon, candidate.lat);
          if (fullSampleResult !== Infinity) {
            candidate.expectedStrokes = fullSampleResult;
            console.log(`Candidate ${i+1} verified: ${candidate.expectedStrokes.toFixed(3)} strokes (was ${originalScore.toFixed(3)}, diff: ${(fullSampleResult - originalScore).toFixed(3)})`);
          }
        }
        
        // Re-sort after full verification
        filteredCandidates.sort((a, b) => a.expectedStrokes - b.expectedStrokes);
        
        optimizationCandidates = filteredCandidates;
        
        const endTime = performance.now();
        console.log(`Optimization completed in ${(endTime - startTime).toFixed(0)}ms`);
        console.log(`Total candidates evaluated: ${allCandidates.length}, Final selection: ${filteredCandidates.length}`);
        console.log(`Showing ${filteredCandidates.length} optimal aim points:`);
        
        filteredCandidates.forEach((candidate, index) => {
          console.log(`${index + 1}. (${candidate.lon.toFixed(4)}, ${candidate.lat.toFixed(4)}) - ${candidate.expectedStrokes.toFixed(3)} strokes`);
        });
        
        // Display candidates visually
        displayOptimizationCandidates();
        
        optimizationInProgress = false;
      }
      
      // Display optimization candidates as colored circles
      function displayOptimizationCandidates() {
        clearOptimizationCandidates();
        
        const colors = [
          Cesium.Color.GOLD,           // 1st place
          Cesium.Color.SILVER,         // 2nd place  
          Cesium.Color.ORANGE,         // 3rd place
          Cesium.Color.LIGHTBLUE,      // 4th place
          Cesium.Color.LIGHTGREEN      // 5th place
        ];
        
        optimizationCandidates.forEach((candidate, index) => {
          const entity = viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(candidate.lon, candidate.lat),
            point: {
              pixelSize: 12,
              color: colors[index],
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 2,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
              disableDepthTestDistance: Number.POSITIVE_INFINITY
            },
            label: {
              text: `${index + 1}`,
              font: '12pt sans-serif',
              fillColor: Cesium.Color.BLACK,
              outlineColor: Cesium.Color.WHITE,
              outlineWidth: 2,
              style: Cesium.LabelStyle.FILL_AND_OUTLINE,
              pixelOffset: new Cesium.Cartesian2(0, -15),
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
            }
          });
          
          candidateEntities.push(entity);
        });
      }
      
      // Clear optimization candidates display
      function clearOptimizationCandidates() {
        candidateEntities.forEach(entity => viewer.entities.remove(entity));
        candidateEntities = [];
      }
      
      // Select an optimization candidate as the new aim point
      function selectOptimizationCandidate(index) {
        if (index >= 0 && index < optimizationCandidates.length) {
          const candidate = optimizationCandidates[index];
          centerLon = candidate.lon;
          centerLat = candidate.lat;
          
          rebuildOval();
          generateRandomPoints();
          updateDistanceDisplays();
          
          console.log(`Selected candidate ${index + 1}: (${candidate.lon.toFixed(4)}, ${candidate.lat.toFixed(4)}) - ${candidate.expectedStrokes.toFixed(2)} strokes`);
        }
      }

      async function moveCameraShot() {
        if (!launchEntity) { console.warn('No launch point set'); return; }

        const jd = Cesium.JulianDate.now();
        const lCarto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(jd));
        const lLon = Cesium.Math.toDegrees(lCarto.longitude);
        const lLat = Cesium.Math.toDegrees(lCarto.latitude);

        const geod = new Cesium.EllipsoidGeodesic();
        geod.setEndPoints(
          Cesium.Cartographic.fromDegrees(lLon, lLat),
          Cesium.Cartographic.fromDegrees(centerLon, centerLat)
        );
        const shotDist = geod.surfaceDistance;

        const headingDeg = computeHeadingDeg(lLon, lLat, centerLon, centerLat);
        const headingRad = Cesium.Math.toRadians(headingDeg);

        const offset = Math.max(Math.pow(shotDist, 0.82) * 1.9 + 20, 50);
        const backwardHeadingRad = headingRad + Math.PI;
        const lLatRad = Cesium.Math.toRadians(lLat);
        const lLonRad = Cesium.Math.toRadians(lLon);
        const R = 6378137.0;
        const dLat = (offset * Math.cos(backwardHeadingRad)) / R;
        const dLon = (offset * Math.sin(backwardHeadingRad)) / (R * Math.cos(lLatRad));
        const destLatRad = lLatRad + dLat;
        const destLonRad = lLonRad + dLon;

        let terrainHeight = 0;
        try {
          const [sample] = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [Cesium.Cartographic.fromDegrees(centerLon, centerLat)]
          );
          terrainHeight = sample.height || 0;
        } catch (e) {
          console.warn('terrain sample failed', e);
        }

        const height = Math.max(Math.pow(shotDist, 0.65) * 3 + terrainHeight + 30, 100);
        const pitch = Cesium.Math.toRadians(-40 + Math.pow(shotDist, 0.5));

        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromRadians(destLonRad, destLatRad, height),
          orientation: {
            heading: Cesium.Math.toRadians(headingDeg),
            pitch,
            roll: 0
          },
          duration: 0.35
        });
      }

      async function shotPOVCamera() {
        if (!launchEntity) { 
          console.warn('No tee position set');
          return; 
        }
        if (centerLon === 0 && centerLat === 0) {
          console.warn('No aim point set');
          return;
        }

        const jd = Cesium.JulianDate.now();
        const teePosition = launchEntity.position.getValue(jd);
        
        const teeCarto = Cesium.Cartographic.fromCartesian(teePosition);
        
        const teeLon = Cesium.Math.toDegrees(teeCarto.longitude);
        const teeLat = Cesium.Math.toDegrees(teeCarto.latitude);
        const aimLon = centerLon;
        const aimLat = centerLat;
        
        // Calculate heading from tee to aim point
        const headingDeg = computeHeadingDeg(teeLon, teeLat, aimLon, aimLat);
        const headingRad = Cesium.Math.toRadians(headingDeg);
        
        // Calculate position 25 meters backward from tee position
        const backwardHeadingRad = headingRad + Math.PI; // Opposite direction
        const offsetDistance = 25; // meters
        
        const R = 6378137.0; // Earth radius in meters
        const teeLatRad = Cesium.Math.toRadians(teeLat);
        const teeLonRad = Cesium.Math.toRadians(teeLon);
        
        const dLat = (offsetDistance * Math.cos(backwardHeadingRad)) / R;
        const dLon = (offsetDistance * Math.sin(backwardHeadingRad)) / (R * Math.cos(teeLatRad));
        
        const cameraLatRad = teeLatRad + dLat;
        const cameraLonRad = teeLonRad + dLon;
        const cameraLat = Cesium.Math.toDegrees(cameraLatRad);
        const cameraLon = Cesium.Math.toDegrees(cameraLonRad);
        
        console.log(`Shot POV: Tee at (${teeLon.toFixed(6)}, ${teeLat.toFixed(6)})`);
        console.log(`Shot POV: Camera at (${cameraLon.toFixed(6)}, ${cameraLat.toFixed(6)})`);
        console.log(`Shot POV: Heading ${headingDeg.toFixed(1)}°, offset distance ${offsetDistance}m`);
        
        // Get terrain height at camera position
        let terrainHeight = 0;
        try {
          const [sample] = await Cesium.sampleTerrainMostDetailed(
            viewer.terrainProvider,
            [Cesium.Cartographic.fromDegrees(cameraLon, cameraLat)]
          );
          terrainHeight = sample.height || 0;
        } catch (e) {
          console.warn('terrain sample failed', e);
        }
        
        // Position camera 6 meters above terrain at camera position
        const cameraHeight = terrainHeight + 6;
        
        // Set camera to view from 25m behind tee position
        viewer.camera.flyTo({
          destination: Cesium.Cartesian3.fromDegrees(cameraLon, cameraLat, cameraHeight),
          orientation: {
            heading: headingRad,  // Look towards aim point
            pitch: Cesium.Math.toRadians(-2),  // Look 2 degrees down
            roll: 0  // No roll
          },
          duration: 1.0
        });
      }

      // Event listeners with debouncing
      function queueManualUpdate() {
        if (sizingFromSkill) return;
        window.performanceManager.debounce('manual-update', () => {
          skillSel.value = 'custom';
          rebuildOval();
          generateRandomPoints();
          updateDistanceDisplays();
        }, 400);
      }

      // Update distance displays
      async function updateDistanceDisplays() {
        if (!launchEntity) return;
        
        const geod = new Cesium.EllipsoidGeodesic();
        const launchCarto = Cesium.Cartographic.fromCartesian(launchEntity.position.getValue(Cesium.JulianDate.now()));
        const lLon = Cesium.Math.toDegrees(launchCarto.longitude);
        const lLat = Cesium.Math.toDegrees(launchCarto.latitude);

        // Batch terrain sampling for all positions at once (PERFORMANCE OPTIMIZATION)
        const positionsToSample = [];
        let intendedDist = 0;
        let shotDist = 0;
        let pinLon, pinLat;
        
        // Calculate intended distance and add oval position to batch
        if (centerLon !== 0 || centerLat !== 0) {
          geod.setEndPoints(
            Cesium.Cartographic.fromDegrees(lLon, lLat),
            Cesium.Cartographic.fromDegrees(centerLon, centerLat)
          );
          intendedDist = geod.surfaceDistance;
          positionsToSample.push(
            new Cesium.Cartographic(Cesium.Math.toRadians(centerLon), Cesium.Math.toRadians(centerLat), 0)
          );
        }
        
        // Calculate shot distance and add pin position to batch
        if (pinEntity) {
          const pinCarto = Cesium.Cartographic.fromCartesian(pinEntity.position.getValue(Cesium.JulianDate.now()));
          pinLon = Cesium.Math.toDegrees(pinCarto.longitude);
          pinLat = Cesium.Math.toDegrees(pinCarto.latitude);
          
          geod.setEndPoints(
            Cesium.Cartographic.fromDegrees(lLon, lLat),
            Cesium.Cartographic.fromDegrees(pinLon, pinLat)
          );
          shotDist = geod.surfaceDistance;
          positionsToSample.push(
            new Cesium.Cartographic(Cesium.Math.toRadians(pinLon), Cesium.Math.toRadians(pinLat), 0)
          );
        }
        
        // Single batched terrain sampling call for all positions
        if (positionsToSample.length > 0) {
          try {
            // First sample the launch position to get accurate tee height
            const launchTerrainSample = await Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              [new Cesium.Cartographic(launchCarto.longitude, launchCarto.latitude, 0)]
            );
            const teeHeight = launchTerrainSample[0].height || 0;
            console.log(`Tee height sampled: ${teeHeight.toFixed(1)}m`);
            
            const sampledPositions = await Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              positionsToSample
            );
            
            let sampleIndex = 0;
            
            // Process intended distance elevation
            if (centerLon !== 0 || centerLat !== 0) {
              const ovalHeight = sampledPositions[sampleIndex].height || 0;
              const elevationChange = ovalHeight - teeHeight;
              const elevationYards = elevationChange * 1.09361;
              
              const elevationText = elevationYards >= 0 
                ? `+${Math.abs(elevationYards).toFixed(0)}y`
                : `-${Math.abs(elevationYards).toFixed(0)}y`;
                
              document.getElementById('intendedDistDisplay').innerHTML = 
                `${formatDistance(intendedDist)}<br><span style="font-size: 10px; color: #888;">${elevationText}</span>`;
              sampleIndex++;
            }
            
            // Process shot distance elevation
            if (pinEntity && sampleIndex < sampledPositions.length) {
              const pinHeight = sampledPositions[sampleIndex].height || 0;
              const elevationChange = pinHeight - teeHeight;
              const elevationYards = elevationChange * 1.09361;
              
              const elevationText = elevationYards >= 0 
                ? `+${Math.abs(elevationYards).toFixed(0)}y`
                : `-${Math.abs(elevationYards).toFixed(0)}y`;
                
              document.getElementById('shotDistDisplay').innerHTML = 
                `${formatDistance(shotDist)}<br><span style="font-size: 10px; color: #888;">${elevationText}</span>`;
            }
            
          } catch (error) {
            console.warn('Failed to calculate elevations with batched terrain sampling:', error);
            // Fallback to distance only
            if (centerLon !== 0 || centerLat !== 0) {
              document.getElementById('intendedDistDisplay').textContent = formatDistance(intendedDist);
            }
            if (pinEntity) {
              document.getElementById('shotDistDisplay').textContent = formatDistance(shotDist);
            }
          }
        } else {
          // No positions to sample, show basic distances
          if (centerLon !== 0 || centerLat !== 0) {
            document.getElementById('intendedDistDisplay').textContent = formatDistance(intendedDist);
          }
          if (pinEntity) {
            document.getElementById('shotDistDisplay').textContent = formatDistance(shotDist);
          }
        }
      }

      // Input event listeners removed - using fixed default values

      selectBtn.addEventListener('click', () => {
        selectingOval = !selectingOval;
        selectingPin = false; selectingLaunch = false;
        selectBtn.classList.toggle('active', selectingOval);
        pinBtn.classList.remove('active');
        launchBtn.classList.remove('active');
      });

      pinBtn.addEventListener('click', () => {
        selectingPin = !selectingPin;
        selectingOval = false; selectingLaunch = false;
        pinBtn.classList.toggle('active', selectingPin);
        selectBtn.classList.remove('active');
        launchBtn.classList.remove('active');
      });

      launchBtn.addEventListener('click', () => {
        selectingLaunch = !selectingLaunch;
        selectingOval = false; selectingPin = false;
        launchBtn.classList.toggle('active', selectingLaunch);
        selectBtn.classList.remove('active');
        pinBtn.classList.remove('active');
      });

      skillSel.addEventListener('change', () => {
        if (skillSel.value === 'custom') {
          jackParams.style.display = 'none';
          jackParamsPct.style.display = 'none';
          return;
        }
        if (skillSel.value === 'jack') {
          jackParams.style.display = '';
          jackParamsPct.style.display = '';
        } else {
          jackParams.style.display = 'none';
          jackParamsPct.style.display = 'none';
        }
        autoSizeFromSkill();
      });

      rollSel.addEventListener('change', () => {
        rollCondition = rollSel.value;
        rebuildOval();
        generateRandomPoints();
      });

      sampleChk.addEventListener('change', updateSampleVisibility);
      camBtn.addEventListener('click', moveCameraShot);
      shotPovBtn.addEventListener('click', shotPOVCamera);
      clearBtn.addEventListener('click', clearAll);
      unitsChk.addEventListener('change', () => {
        // Update all distance displays when units change
        updateDistanceDisplays();
        updateMaxDriveUnits(); // Update max drive distance units
        if (sampleEntities.length > 0) {
          generateRandomPoints(); // Regenerate to update avg display
        }
      });
      jackOfflineEl.addEventListener('input', () => { if (skillSel.value === 'jack') autoSizeFromSkill(); });
      jackDistPctEl.addEventListener('input', () => { if (skillSel.value === 'jack') autoSizeFromSkill(); });
      
      // Shot type selection event handlers
      approachShotBtn.addEventListener('click', async () => {
        console.log(`APPROACH BUTTON CLICKED: currentShotType = ${currentShotType}`);
        if (currentShotType !== 'approach') {
          console.log('Switching to approach shot mode');
          currentShotType = 'approach';
          updateShotTypeButtons();
          
          // Re-set positions for the current hole with the new shot type
          if (currentHoleId !== null && currentHoleId > 0) {
            console.log(`Switching to approach shot for hole ${currentHoleId}`);
            await setDefaultPositionsForHole(currentHoleId, true); // Pass true to preserve shot type
            await autoSizeFromSkill();
            await generateRandomPoints();
            updateDistanceDisplays();
          }
        } else {
          console.log('Already in approach shot mode, no change needed');
        }
      });
      
      teeShotBtn.addEventListener('click', async () => {
        console.log(`TEE BUTTON CLICKED: currentShotType = ${currentShotType}`);
        if (currentShotType !== 'tee') {
          console.log('Switching to tee shot mode');
          currentShotType = 'tee';
          updateShotTypeButtons();
          
          // Re-set positions for the current hole with the new shot type
          if (currentHoleId !== null && currentHoleId > 0) {
            console.log(`Switching to tee shot for hole ${currentHoleId}`);
            await setDefaultPositionsForHole(currentHoleId, true); // Pass true to preserve shot type
            await autoSizeFromSkill();
            await generateRandomPoints();
            updateDistanceDisplays();
          }
        } else {
          console.log('Already in tee shot mode, no change needed');
        }
      });

      // ==================== OPTIMIZATION EVENT HANDLERS ====================
      
      // Get legacy optimization UI elements (some may not exist anymore)
      const markHazardBtn = document.getElementById('markHazardBtn');
      const markOBBtn = document.getElementById('markOBBtn');
      const clearHazardsBtn = document.getElementById('clearHazardsBtn');
      
      // Function to update max drive distance units and value
      function updateMaxDriveUnits() {
        // Use the toolbar version instead
        updateToolbarMaxDriveUnits();
      }
      
      // Old optimization event handlers removed - using toolbar versions now
      
      // Clear hazards/OB button handler (legacy - if button exists)
      if (clearHazardsBtn) {
        clearHazardsBtn.addEventListener('click', () => {
        // Clear user-defined arrays (legacy compatibility)
        if (typeof userDefinedHazards !== 'undefined') userDefinedHazards.length = 0;
        if (typeof userDefinedOB !== 'undefined') userDefinedOB.length = 0;
        
        // Reset any current polygon drawing
        if (markingHazard || markingOB) {
          markingHazard = false;
          markingOB = false;
          currentPolygonPoints.length = 0;
          markHazardBtn.textContent = '⚠️ Mark Hazard';
          markOBBtn.textContent = '🚫 Mark OB';
          markHazardBtn.disabled = false;
          markOBBtn.disabled = false;
          
          if (drawingPolygonEntity) {
            viewer.entities.remove(drawingPolygonEntity);
            drawingPolygonEntity = null;
          }
        }
        
        // Remove all user-defined polygon entities from the viewer
        // Note: This removes ALL entities, which includes hazard/OB polygons and point markers
        // We'll need to rebuild the sample points after this
        const entitiesToRemove = [];
        for (let i = 0; i < viewer.entities.values.length; i++) {
          const entity = viewer.entities.values[i];
          // Remove polygons and point markers that look like user-defined hazards/OB
          if (entity.polygon || (entity.point && entity.point.pixelSize && entity.point.pixelSize.getValue() === 6)) {
            entitiesToRemove.push(entity);
          }
        }
        
        entitiesToRemove.forEach(entity => viewer.entities.remove(entity));
        
        console.log('All hazards and OB areas cleared');
        
        // Regenerate sample points to reflect the cleared penalties
        if (sampleEntities.length > 0) {
          generateRandomPoints();
        }
        });
      }
      
      // ==================== OPTIMIZATION TOOLBAR EVENT HANDLERS ====================
      
      // Get toolbar elements
      const toggleOptToolbar = document.getElementById('toggleOptToolbar');
      const optimizationToolbarContent = document.getElementById('optimizationToolbarContent');
      const maxDriveToolbar = document.getElementById('maxDriveToolbar');
      const maxDriveUnitsToolbar = document.getElementById('maxDriveUnitsToolbar');
      const optimizeToolbarBtn = document.getElementById('optimizeToolbarBtn');
      const clearOptimizationToolbarBtn = document.getElementById('clearOptimizationToolbarBtn');
      const optimizationResultsToolbar = document.getElementById('optimizationResultsToolbar');
      const candidatesListToolbar = document.getElementById('candidatesListToolbar');
      const clearAllConditionsBtn = document.getElementById('clearAllConditionsBtn');
      const clearLastBtn = document.getElementById('clearLastBtn');
      const drawingStatus = document.getElementById('drawingStatus');
      const drawingInstructions = document.getElementById('drawingInstructions');
      const finishDrawingBtn = document.getElementById('finishDrawingBtn');
      
      // Condition marking buttons
      const conditionButtons = {
        water: document.getElementById('markWaterBtn'),
        bunkers: document.getElementById('markBunkerBtn'),
        greens: document.getElementById('markGreenBtn'),
        tees: document.getElementById('markTeeBtn'),
        fairways: document.getElementById('markFairwayBtn'),
        roughs: document.getElementById('markRoughBtn'),
        hazards: document.getElementById('markHazardToolbarBtn'),
        ob: document.getElementById('markOBToolbarBtn'),
        recovery: document.getElementById('markRecoveryBtn')
      };
      
      // Condition colors and materials for visualization
      const conditionStyles = {
        water: { color: Cesium.Color.AQUAMARINE.withAlpha(0.4), outline: Cesium.Color.BLUE },
        bunkers: { color: Cesium.Color.SANDYBROWN.withAlpha(0.4), outline: Cesium.Color.GOLDENROD },
        greens: { color: Cesium.Color.LIME.withAlpha(0.4), outline: Cesium.Color.GREEN },
        tees: { color: Cesium.Color.LIGHTGRAY.withAlpha(0.4), outline: Cesium.Color.GRAY },
        fairways: { color: Cesium.Color.GREEN.withAlpha(0.3), outline: Cesium.Color.DARKGREEN },
        roughs: { color: Cesium.Color.ORANGE.withAlpha(0.4), outline: Cesium.Color.DARKORANGE },
        hazards: { color: Cesium.Color.RED.withAlpha(0.3), outline: Cesium.Color.DARKRED },
        ob: { color: Cesium.Color.WHITE.withAlpha(0.5), outline: Cesium.Color.BLACK },
        recovery: { color: Cesium.Color.PURPLE.withAlpha(0.4), outline: Cesium.Color.DARKVIOLET }
      };
      
      // Toolbar collapse/expand
      toggleOptToolbar.addEventListener('click', () => {
        const isCollapsed = optimizationToolbarContent.style.display === 'none';
        if (isCollapsed) {
          optimizationToolbarContent.style.display = 'block';
          toggleOptToolbar.textContent = '▼';
        } else {
          optimizationToolbarContent.style.display = 'none';
          toggleOptToolbar.textContent = '▶';
        }
      });
      
      // Sync max drive distance with main toolbar
      function updateToolbarMaxDriveUnits() {
        const useYards = unitsChk.checked;
        if (useYards) {
          maxDriveUnitsToolbar.textContent = 'yards';
          const currentYards = Math.round(maxDriveDistance * 1.09361);
          maxDriveToolbar.value = currentYards;
          maxDriveToolbar.min = '55';
          maxDriveToolbar.max = '440';
        } else {
          maxDriveUnitsToolbar.textContent = 'meters';
          maxDriveToolbar.value = Math.round(maxDriveDistance);
          maxDriveToolbar.min = '50';
          maxDriveToolbar.max = '400';
        }
      }
      
      // Max drive distance toolbar input handler
      maxDriveToolbar.addEventListener('input', () => {
        const value = parseFloat(maxDriveToolbar.value);
        const useYards = unitsChk.checked;
        
        if (value && value > 0) {
          if (useYards) {
            maxDriveDistance = value * 0.9144;
            console.log(`Max drive distance updated to ${value} yards (${maxDriveDistance.toFixed(1)}m)`);
          } else {
            maxDriveDistance = value;
            console.log(`Max drive distance updated to ${maxDriveDistance}m`);
          }
          // Sync with main toolbar
          // No longer needed - using toolbar only
        }
      });
      
      // Optimization button handler (duplicate of main functionality)
      optimizeToolbarBtn.addEventListener('click', async () => {
        if (optimizationInProgress) {
          console.warn('Optimization already in progress');
          return;
        }
        
        optimizeToolbarBtn.textContent = '⏳ Optimizing...';
        optimizeToolbarBtn.disabled = true;
        
        try {
          await optimizeAimPoint();
          
          // Update toolbar results display
          if (optimizationCandidates.length > 0) {
            optimizationResultsToolbar.style.display = 'block';
            candidatesListToolbar.innerHTML = optimizationCandidates.map((candidate, index) => 
              `<div style="margin-bottom: 2px;">
                ${index + 1}. ${candidate.expectedStrokes.toFixed(2)} strokes 
                <span style="color: #666;">(${candidate.lon.toFixed(4)}, ${candidate.lat.toFixed(4)})</span>
              </div>`
            ).join('');
          }
        } catch (error) {
          console.error('Optimization failed:', error);
        } finally {
          optimizeToolbarBtn.textContent = '🎯 Optimize Aim Point';
          optimizeToolbarBtn.disabled = false;
        }
      });
      
      // Clear optimization results toolbar handler
      clearOptimizationToolbarBtn.addEventListener('click', () => {
        clearOptimizationCandidates();
        optimizationResultsToolbar.style.display = 'none';
        console.log('Optimization results cleared from toolbar');
      });
      
      // Condition marking event handlers
      Object.entries(conditionButtons).forEach(([conditionType, button]) => {
        button.addEventListener('click', () => {
          startDrawingCondition(conditionType);
        });
      });
      
      // Start drawing a specific condition type
      function startDrawingCondition(conditionType) {
        // Reset any current drawing
        if (currentDrawingType) {
          finishCurrentDrawing();
        }
        
        currentDrawingType = conditionType;
        currentPolygonPoints = [];
        
        // Update UI
        drawingStatus.style.display = 'block';
        drawingInstructions.textContent = `Click points to mark ${conditionType} area. Click "Finish Drawing" when done.`;
        
        // Disable all condition buttons except the active one
        Object.entries(conditionButtons).forEach(([type, btn]) => {
          btn.disabled = type !== conditionType;
          if (type === conditionType) {
            btn.style.opacity = '0.7';
            btn.textContent = btn.textContent.replace('Mark', '✅ Drawing');
          }
        });
        
        console.log(`Started drawing ${conditionType} area`);
      }
      
      // Finish current drawing
      function finishCurrentDrawing() {
        if (!currentDrawingType || currentPolygonPoints.length < 3) {
          cancelCurrentDrawing();
          return;
        }
        
        // Add to user-defined conditions
        userDefinedConditions[currentDrawingType].push([...currentPolygonPoints]);
        
        // Create visual polygon
        const style = conditionStyles[currentDrawingType];
        const entity = viewer.entities.add({
          polygon: {
            hierarchy: new Cesium.PolygonHierarchy(
              currentPolygonPoints.map(p => Cesium.Cartesian3.fromDegrees(p.lon, p.lat))
            ),
            material: style.color,
            outline: true,
            outlineColor: style.outline,
            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
          }
        });
        
        // Track the condition for "Clear Last" functionality
        const conditionRecord = {
          type: currentDrawingType,
          points: [...currentPolygonPoints],
          entity: entity,
          timestamp: Date.now()
        };
        conditionHistory.push(conditionRecord);
        conditionEntities.push(entity);
        
        console.log(`Added ${currentDrawingType} area with ${currentPolygonPoints.length} points`);
        
        // Reset drawing state
        resetDrawingState();
        
        // Regenerate sample points to reflect new condition
        if (sampleEntities.length > 0) {
          generateRandomPoints();
        }
      }
      
      // Cancel current drawing
      function cancelCurrentDrawing() {
        if (drawingPolygonEntity) {
          viewer.entities.remove(drawingPolygonEntity);
          drawingPolygonEntity = null;
        }
        resetDrawingState();
      }
      
      // Reset drawing state
      function resetDrawingState() {
        currentDrawingType = null;
        currentPolygonPoints = [];
        drawingStatus.style.display = 'none';
        
        // Re-enable all buttons and reset text
        Object.entries(conditionButtons).forEach(([type, btn]) => {
          btn.disabled = false;
          btn.style.opacity = '1';
          const emoji = btn.textContent.split(' ')[0];
          const name = type.charAt(0).toUpperCase() + type.slice(1);
          btn.textContent = `${emoji} ${name}`;
        });
        
        if (drawingPolygonEntity) {
          viewer.entities.remove(drawingPolygonEntity);
          drawingPolygonEntity = null;
        }
      }
      
      // Finish drawing button handler
      finishDrawingBtn.addEventListener('click', finishCurrentDrawing);
      
      // Clear last condition handler
      clearLastBtn.addEventListener('click', () => {
        if (conditionHistory.length === 0) {
          console.log('No conditions to clear');
          return;
        }
        
        // Get the most recent condition
        const lastCondition = conditionHistory.pop();
        
        // Remove from user-defined conditions array
        const conditionArray = userDefinedConditions[lastCondition.type];
        const matchIndex = conditionArray.findIndex(polygon => 
          polygon.length === lastCondition.points.length &&
          polygon.every((point, i) => 
            Math.abs(point.lon - lastCondition.points[i].lon) < 0.0001 &&
            Math.abs(point.lat - lastCondition.points[i].lat) < 0.0001
          )
        );
        
        if (matchIndex >= 0) {
          conditionArray.splice(matchIndex, 1);
        }
        
        // Remove visual entity
        viewer.entities.remove(lastCondition.entity);
        const entityIndex = conditionEntities.indexOf(lastCondition.entity);
        if (entityIndex >= 0) {
          conditionEntities.splice(entityIndex, 1);
        }
        
        console.log(`Cleared last ${lastCondition.type} condition`);
        
        // Regenerate sample points
        if (sampleEntities.length > 0) {
          generateRandomPoints();
        }
      });

      // Clear all conditions handler
      clearAllConditionsBtn.addEventListener('click', () => {
        // Clear all user-defined condition arrays
        Object.keys(userDefinedConditions).forEach(key => {
          userDefinedConditions[key].length = 0;
        });
        
        // Clear tracking arrays
        conditionHistory.length = 0;
        conditionEntities.length = 0;
        
        // Cancel any current drawing
        cancelCurrentDrawing();
        
        // Remove all user-defined polygons and point markers from viewer
        const entitiesToRemove = [];
        for (let i = 0; i < viewer.entities.values.length; i++) {
          const entity = viewer.entities.values[i];
          if (entity.polygon || (entity.point && entity.point.pixelSize && entity.point.pixelSize.getValue() === 6)) {
            entitiesToRemove.push(entity);
          }
        }
        
        entitiesToRemove.forEach(entity => viewer.entities.remove(entity));
        
        console.log('All user-defined conditions cleared');
        
        // Regenerate sample points
        if (sampleEntities.length > 0) {
          generateRandomPoints();
        }
      });
      
      // Hazard and OB marking variables (legacy support)
      let markingHazard = false;
      let markingOB = false;
      
      // Mark hazard button handler (legacy - if button exists)
      if (markHazardBtn) {
        markHazardBtn.addEventListener('click', () => {
        if (markingHazard) {
          // Complete current hazard polygon
          completeHazardPolygon();
        } else {
          // Start marking hazard
          markingHazard = true;
          markingOB = false;
          currentPolygonPoints = [];
          markHazardBtn.textContent = '✅ Finish Hazard';
          markOBBtn.disabled = true;
          console.log('Click points to mark hazard area, click "Finish Hazard" when done');
        }
        });
      }
      
      // Mark OB button handler (legacy - if button exists)
      if (markOBBtn) {
        markOBBtn.addEventListener('click', () => {
        if (markingOB) {
          // Complete current OB polygon
          completeOBPolygon();
        } else {
          // Start marking OB
          markingOB = true;
          markingHazard = false;
          currentPolygonPoints = [];
          markOBBtn.textContent = '✅ Finish OB';
          markHazardBtn.disabled = true;
          console.log('Click points to mark out of bounds area, click "Finish OB" when done');
        }
        });
      }
      
      // Complete hazard polygon
      function completeHazardPolygon() {
        if (currentPolygonPoints.length >= 3) {
          // Legacy compatibility - this should use the new system
          if (typeof userDefinedHazards !== 'undefined') {
            userDefinedHazards.push([...currentPolygonPoints]);
          }
          
          // Add visual polygon
          const entity = viewer.entities.add({
            polygon: {
              hierarchy: new Cesium.PolygonHierarchy(
                currentPolygonPoints.map(p => Cesium.Cartesian3.fromDegrees(p.lon, p.lat))
              ),
              material: Cesium.Color.RED.withAlpha(0.3),
              outline: true,
              outlineColor: Cesium.Color.RED,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
            }
          });
          
          console.log(`Added hazard area with ${currentPolygonPoints.length} points`);
        }
        
        // Reset marking state
        markingHazard = false;
        currentPolygonPoints = [];
        markHazardBtn.textContent = '⚠️ Mark Hazard';
        markOBBtn.disabled = false;
        
        if (drawingPolygonEntity) {
          viewer.entities.remove(drawingPolygonEntity);
          drawingPolygonEntity = null;
        }
      }
      
      // Complete OB polygon
      function completeOBPolygon() {
        if (currentPolygonPoints.length >= 3) {
          // Legacy compatibility - this should use the new system
          if (typeof userDefinedOB !== 'undefined') {
            userDefinedOB.push([...currentPolygonPoints]);
          }
          
          // Add visual polygon
          const entity = viewer.entities.add({
            polygon: {
              hierarchy: new Cesium.PolygonHierarchy(
                currentPolygonPoints.map(p => Cesium.Cartesian3.fromDegrees(p.lon, p.lat))
              ),
              material: Cesium.Color.WHITE.withAlpha(0.5),
              outline: true,
              outlineColor: Cesium.Color.BLACK,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
            }
          });
          
          console.log(`Added OB area with ${currentPolygonPoints.length} points`);
        }
        
        // Reset marking state
        markingOB = false;
        currentPolygonPoints = [];
        markOBBtn.textContent = '🚫 Mark OB';
        markHazardBtn.disabled = false;
        
        if (drawingPolygonEntity) {
          viewer.entities.remove(drawingPolygonEntity);
          drawingPolygonEntity = null;
        }
      }

      // Mouse click handler for placing points
      const handler = new Cesium.ScreenSpaceEventHandler(viewer.scene.canvas);
      handler.setInputAction(async (movement) => {
        const cartesian = viewer.scene.pickPosition(movement.position);
        if (!cartesian) return;
        const carto = Cesium.Cartographic.fromCartesian(cartesian);
        const lon = Cesium.Math.toDegrees(carto.longitude);
        const lat = Cesium.Math.toDegrees(carto.latitude);

        // Check for optimization candidate selection first
        const pickedObject = viewer.scene.pick(movement.position);
        if (pickedObject && pickedObject.id) {
          const entity = pickedObject.id;
          
          // Check if clicked on an optimization candidate
          const candidateIndex = candidateEntities.indexOf(entity);
          if (candidateIndex >= 0) {
            selectOptimizationCandidate(candidateIndex);
            return;
          }
        }

        // Handle optimization toolbar condition drawing
        if (currentDrawingType) {
          currentPolygonPoints.push({ lon, lat });
          
          // Add a point marker
          const style = conditionStyles[currentDrawingType];
          viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat),
            point: {
              pixelSize: 6,
              color: style.outline,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 1,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
            }
          });
          
          // Update the drawing polygon
          if (currentPolygonPoints.length >= 3) {
            if (drawingPolygonEntity) {
              viewer.entities.remove(drawingPolygonEntity);
            }
            
            drawingPolygonEntity = viewer.entities.add({
              polygon: {
                hierarchy: new Cesium.PolygonHierarchy(
                  currentPolygonPoints.map(p => Cesium.Cartesian3.fromDegrees(p.lon, p.lat))
                ),
                material: style.color,
                outline: true,
                outlineColor: style.outline,
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
              }
            });
          }
          
          console.log(`Added point ${currentPolygonPoints.length} for ${currentDrawingType} area`);
          
          // Update sample points in real-time while drawing (if we have 3+ points for a valid polygon)
          if (currentPolygonPoints.length >= 3 && sampleEntities.length > 0) {
            generateRandomPoints();
          }
          
          return;
        }

        // Handle legacy hazard/OB marking (for backward compatibility)
        if (markingHazard || markingOB) {
          currentPolygonPoints.push({ lon, lat });
          
          // Add a point marker
          viewer.entities.add({
            position: Cesium.Cartesian3.fromDegrees(lon, lat),
            point: {
              pixelSize: 6,
              color: markingHazard ? Cesium.Color.RED : Cesium.Color.WHITE,
              outlineColor: Cesium.Color.BLACK,
              outlineWidth: 1,
              heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
            }
          });
          
          // Update the drawing polygon
          if (currentPolygonPoints.length >= 3) {
            if (drawingPolygonEntity) {
              viewer.entities.remove(drawingPolygonEntity);
            }
            
            drawingPolygonEntity = viewer.entities.add({
              polygon: {
                hierarchy: new Cesium.PolygonHierarchy(
                  currentPolygonPoints.map(p => Cesium.Cartesian3.fromDegrees(p.lon, p.lat))
                ),
                material: markingHazard ? 
                  Cesium.Color.RED.withAlpha(0.2) : 
                  Cesium.Color.WHITE.withAlpha(0.3),
                outline: true,
                outlineColor: markingHazard ? Cesium.Color.RED : Cesium.Color.BLACK,
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
              }
            });
          }
          
          console.log(`Added point ${currentPolygonPoints.length} for ${markingHazard ? 'hazard' : 'OB'} area`);
          return;
        }

        // Existing point placement logic
        if (selectingOval) {
          centerLon = lon; centerLat = lat;
          clearOptimizationCandidates(); // Clear previous optimization
          rebuildOval();
          autoSizeFromSkill();
          generateRandomPoints();
          updateDistanceDisplays();
        } else if (selectingPin) {
          await placePin(lon, lat);
          clearOptimizationCandidates(); // Clear previous optimization
          generateRandomPoints();
          updateDistanceDisplays();
        } else if (selectingLaunch) {
          if (launchEntity) viewer.entities.remove(launchEntity);
          clearOptimizationCandidates(); // Clear previous optimization
          
          // Sample terrain for proper height
          try {
            const [sample] = await Cesium.sampleTerrainMostDetailed(
              viewer.terrainProvider,
              [new Cesium.Cartographic(Cesium.Math.toRadians(lon), Cesium.Math.toRadians(lat), 0)]
            );
            const terrainHeight = sample.height || 0;
            
            launchEntity = viewer.entities.add({
              position: Cesium.Cartesian3.fromDegrees(lon, lat),
              point: { pixelSize: 5, color: Cesium.Color.CYAN, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, disableDepthTestDistance: 1000 }
            });
          } catch (error) {
            launchEntity = viewer.entities.add({
              position: Cesium.Cartesian3.fromDegrees(lon, lat),
              point: { pixelSize: 5, color: Cesium.Color.CYAN, heightReference: Cesium.HeightReference.CLAMP_TO_GROUND, disableDepthTestDistance: 1000 }
            });
          }
          
          autoSizeFromSkill();
          updateDistanceDisplays();
        }
      }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

      // Initialize with default center
      centerLon = -84.5; centerLat = 39.1; // Default Cincinnati area
      rebuildOval();
      
      // Initialize max drive distance units display
      updateMaxDriveUnits();

      console.log('=== OPTIMIZED SCRIPT COMPLETED ===');
      
    } catch(error) {
      console.error('=== OPTIMIZED SCRIPT ERROR ===', error);
      document.getElementById('loadingIndicator').innerHTML = 
        '<div style="color: red;">Error loading application: ' + error.message + '</div>';
    }
  })();
  </script>
</body>
</html>